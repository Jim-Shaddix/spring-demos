[{"name":"A-IM","example":"A-IM: feed","short-description":"Instance manipulations that are acceptable in the response. Defined in RFC 3229","long-description":null,"type":"REQUEST"},{"name":"Accept","example":"Accept: application/json","short-description":"The media type/types acceptable","long-description":"<p> The Accept request-header field can be used to specify certain media types which are acceptable for the response. Accept headers can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image. </p>\n<pre>       Accept         = \"Accept\" \":\"\r\n                        #( media-range [ accept-params ] )\r\n</pre>\n<pre>       media-range    = ( \"*/*\"\r\n                        | ( type \"/\" \"*\" )\r\n                        | ( type \"/\" subtype )\r\n                        ) *( \";\" parameter )\r\n       accept-params  = \";\" \"q\" \"=\" qvalue *( accept-extension )\r\n       accept-extension = \";\" token [ \"=\" ( token | quoted-string ) ]\r\n</pre>\n<p> The asterisk \"*\" character is used to group media types into ranges, with \"*/*\" indicating all media types and \"type/*\" indicating all subtypes of that type. The media-range MAY include media type parameters that are applicable to that range. </p>\n<p> Each media-range MAY be followed by one or more accept-params, beginning with the \"q\" parameter for indicating a relative quality factor. The first \"q\" parameter (if any) separates the media-range parameter(s) from the accept-params. Quality factors allow the user or user agent to indicate the relative degree of preference for that media-range, using the qvalue scale from 0 to 1 (section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.9\">3.9</a>). The default value is q=1. </p>\n<pre>      Note: Use of the \"q\" parameter name to separate media type\r\n      parameters from Accept extension parameters is due to historical\r\n      practice. Although this prevents any media type parameter named\r\n      \"q\" from being used with a media range, such an event is believed\r\n      to be unlikely given the lack of any \"q\" parameters in the IANA\r\n      media type registry and the rare usage of any media type\r\n      parameters in Accept. Future media types are discouraged from\r\n      registering any parameter named \"q\".\r\n</pre>\n<p> The example </p>\n<pre>       Accept: audio/*; q=0.2, audio/basic\r\n</pre>\n<p> SHOULD be interpreted as \"I prefer audio/basic, but send me any audio type if it is the best available after an 80% mark-down in quality.\" </p>\n<p> If no Accept header field is present, then it is assumed that the client accepts all media types. If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response. </p>\n<p> A more elaborate example is </p>\n<pre>       Accept: text/plain; q=0.5, text/html,\r\n               text/x-dvi; q=0.8, text/x-c\r\n</pre>\n<p> Verbally, this would be interpreted as \"text/html and text/x-c are the preferred media types, but if they do not exist, then send the text/x-dvi entity, and if that does not exist, send the text/plain entity.\" </p>\n<p> Media ranges can be overridden by more specific media ranges or specific media types. If more than one media range applies to a given type, the most specific reference has precedence. For example, </p>\n<pre>       Accept: text/*, text/html, text/html;level=1, */*\r\n</pre>\n<p> have the following precedence: </p>\n<pre>       1) text/html;level=1\r\n       2) text/html\r\n       3) text/*\r\n       4) */*\r\n</pre>\n<p> The media type quality factor associated with a given type is determined by finding the media range with the highest precedence which matches that type. For example, </p>\n<pre>       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,\r\n               text/html;level=2;q=0.4, */*;q=0.5\r\n</pre>\n<p> would cause the following values to be associated: </p>\n<pre>       text/html;level=1         = 1\r\n       text/html                 = <a rel=\"xref\" href=\"rfc2616-sec0.html#sec0.7\">0.7</a>\r\n       text/plain                = <a rel=\"xref\" href=\"rfc2616-sec0.html#sec0.3\">0.3</a>\r\n</pre>\n<pre>       image/jpeg                = 0.5\r\n       text/html;level=2         = <a rel=\"xref\" href=\"rfc2616-sec0.html#sec0.4\">0.4</a>\r\n       text/html;level=3         = <a rel=\"xref\" href=\"rfc2616-sec0.html#sec0.7\">0.7</a>\r\n</pre>\n<pre>      Note: A user agent might be provided with a default set of quality\r\n      values for certain media ranges. However, unless the user agent is\r\n      a closed system which cannot interact with other rendering agents,\r\n      this default set ought to be configurable by the user.\r\n</pre>","type":"REQUEST"},{"name":"Accept-Charset","example":"Accept-Charset: utf-8","short-description":"The charset acceptable","long-description":"<p> The Accept-Charset request-header field can be used to indicate what character sets are acceptable for the response. This field allows clients capable of understanding more comprehensive or special- purpose character sets to signal that capability to a server which is capable of representing documents in those character sets. </p>\n<pre>      Accept-Charset = \"Accept-Charset\" \":\"\r\n              1#( ( charset | \"*\" )[ \";\" \"q\" \"=\" qvalue ] )\r\n</pre>\n<p> Character set values are described in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.4\">3.4</a>. Each charset MAY be given an associated quality value which represents the user's preference for that charset. The default value is q=1. An example is </p>\n<pre>      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8\r\n</pre>\n<p> The special value \"*\", if present in the Accept-Charset field, matches every character set (including ISO-8859-1) which is not mentioned elsewhere in the Accept-Charset field. If no \"*\" is present in an Accept-Charset field, then all character sets not explicitly mentioned get a quality value of 0, except for ISO-8859-1, which gets a quality value of 1 if not explicitly mentioned. </p>\n<p> If no Accept-Charset header is present, the default is that any character set is acceptable. If an Accept-Charset header is present, and if the server cannot send a response which is acceptable according to the Accept-Charset header, then the server SHOULD send an error response with the 406 (not acceptable) status code, though the sending of an unacceptable response is also allowed. </p>","type":"REQUEST"},{"name":"Accept-Encoding","example":"Accept-Encoding: gzip, deflate","short-description":"List of acceptable encodings","long-description":"<p> The Accept-Encoding request-header field is similar to Accept, but restricts the content-codings (section 3.5) that are acceptable in the response. </p>\n<pre>       Accept-Encoding  = \"Accept-Encoding\" \":\"\r\n</pre>\n<pre>                          1#( codings [ \";\" \"q\" \"=\" qvalue ] )\r\n       codings          = ( content-coding | \"*\" )\r\n</pre>\n<p> Examples of its use are: </p>\n<pre>       Accept-Encoding: compress, gzip\r\n       Accept-Encoding:\r\n       Accept-Encoding: *\r\n       Accept-Encoding: compress;q=0.5, gzip;q=1.0\r\n       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0\r\n</pre>\n<p> A server tests whether a content-coding is acceptable, according to an Accept-Encoding field, using these rules: </p>\n<pre>      1. If the content-coding is one of the content-codings listed in\r\n         the Accept-Encoding field, then it is acceptable, unless it is\r\n         accompanied by a qvalue of 0. (As defined in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.9\">3.9</a>, a\r\n         qvalue of 0 means \"not acceptable.\")\r\n</pre>\n<pre>      2. The special \"*\" symbol in an Accept-Encoding field matches any\r\n         available content-coding not explicitly listed in the header\r\n         field.\r\n</pre>\n<pre>      3. If multiple content-codings are acceptable, then the acceptable\r\n         content-coding with the highest non-zero qvalue is preferred.\r\n</pre>\n<pre>      4. The \"identity\" content-coding is always acceptable, unless\r\n         specifically refused because the Accept-Encoding field includes\r\n         \"identity;q=0\", or because the field includes \"*;q=0\" and does\r\n         not explicitly include the \"identity\" content-coding. If the\r\n         Accept-Encoding field-value is empty, then only the \"identity\"\r\n         encoding is acceptable.\r\n</pre>\n<p> If an Accept-Encoding field is present in a request, and if the server cannot send a response which is acceptable according to the Accept-Encoding header, then the server SHOULD send an error response with the 406 (Not Acceptable) status code. </p>\n<p> If no Accept-Encoding field is present in a request, the server MAY assume that the client will accept any content coding. In this case, if \"identity\" is one of the available content-codings, then the server SHOULD use the \"identity\" content-coding, unless it has additional information that a different content-coding is meaningful to the client. </p>\n<pre>      Note: If the request does not include an Accept-Encoding field,\r\n      and if the \"identity\" content-coding is unavailable, then\r\n      content-codings commonly understood by HTTP/1.0 clients (i.e.,\r\n</pre>\n<pre>      \"gzip\" and \"compress\") are preferred; some older clients\r\n      improperly display messages sent with other content-codings.  The\r\n      server might also make this decision based on information about\r\n      the particular user-agent or client.\r\n</pre>\n<pre>      Note: Most HTTP/1.0 applications do not recognize or obey qvalues\r\n      associated with content-codings. This means that qvalues will not\r\n      work and are not permitted with x-gzip or x-compress.\r\n</pre>","type":"REQUEST"},{"name":"Accept-Language","example":"Accept-Language: en-US","short-description":"List of acceptable languages","long-description":"<p> The Accept-Language request-header field is similar to Accept, but restricts the set of natural languages that are preferred as a response to the request. Language tags are defined in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.10\">3.10</a>. </p>\n<pre>       Accept-Language = \"Accept-Language\" \":\"\r\n                         1#( language-range [ \";\" \"q\" \"=\" qvalue ] )\r\n       language-range  = ( ( 1*8ALPHA *( \"-\" 1*8ALPHA ) ) | \"*\" )\r\n</pre>\n<p> Each language-range MAY be given an associated quality value which represents an estimate of the user's preference for the languages specified by that range. The quality value defaults to \"q=1\". For example, </p>\n<pre>       Accept-Language: da, en-gb;q=0.8, en;q=0.7\r\n</pre>\n<p> would mean: \"I prefer Danish, but will accept British English and other types of English.\" A language-range matches a language-tag if it exactly equals the tag, or if it exactly equals a prefix of the tag such that the first tag character following the prefix is \"-\". The special range \"*\", if present in the Accept-Language field, matches every tag not matched by any other range present in the Accept-Language field. </p>\n<pre>      Note: This use of a prefix matching rule does not imply that\r\n      language tags are assigned to languages in such a way that it is\r\n      always true that if a user understands a language with a certain\r\n      tag, then this user will also understand all languages with tags\r\n      for which this tag is a prefix. The prefix rule simply allows the\r\n      use of prefix tags if this is the case.\r\n</pre>\n<p> The language quality factor assigned to a language-tag by the Accept-Language field is the quality value of the longest language- range in the field that matches the language-tag. If no language- range in the field matches the tag, the language quality factor assigned is 0. If no Accept-Language header is present in the request, the server </p>\n<p> SHOULD assume that all languages are equally acceptable. If an Accept-Language header is present, then all languages which are assigned a quality factor greater than 0 are acceptable. </p>\n<p> It might be contrary to the privacy expectations of the user to send an Accept-Language header with the complete linguistic preferences of the user in every request. For a discussion of this issue, see section <a rel=\"xref\" href=\"rfc2616-sec15.html#sec15.1.4\">15.1.4</a>. </p>\n<p> As intelligibility is highly dependent on the individual user, it is recommended that client applications make the choice of linguistic preference available to the user. If the choice is not made available, then the Accept-Language header field MUST NOT be given in the request. </p>\n<pre>      Note: When making the choice of linguistic preference available to\r\n      the user, we remind implementors of  the fact that users are not\r\n      familiar with the details of language matching as described above,\r\n      and should provide appropriate guidance. As an example, users\r\n      might assume that on selecting \"en-gb\", they will be served any\r\n      kind of English document if British English is not available. A\r\n      user agent might suggest in such a case to add \"en\" to get the\r\n      best matching behavior.\r\n</pre>","type":"REQUEST"},{"name":"Accept-Datetime","example":"Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT","short-description":"Request a past version of the resource prior to the datetime passed","long-description":null,"type":"REQUEST"},{"name":"Access-Control-Request-Method","example":"Access-Control-Request-Method: GET","short-description":"Used in a CORS request","long-description":null,"type":"REQUEST"},{"name":"Access-Control-Request-Headers","example":"Access-Control-Request-Headers: origin, x-requested-with, accept","short-description":"Used in a CORS request","long-description":null,"type":"REQUEST"},{"name":"Authorization","example":"Authorization: Basic 34i3j4iom2323==","short-description":"HTTP basic authentication credentials","long-description":"<pre>      A user agent that wishes to authenticate itself with a server--\r\n      usually, but not necessarily, after receiving a 401 response--does\r\n      so by including an Authorization request-header field with the\r\n      request.  The Authorization field value consists of credentials\r\n      containing the authentication information of the user agent for\r\n      the realm of the resource being requested.\r\n</pre>\n<pre>          Authorization  = \"Authorization\" \":\" credentials\r\n</pre>\n<pre>      HTTP access authentication is described in \"HTTP Authentication:\r\n      Basic and Digest Access Authentication\" <a rel=\"bibref\" href=\"rfc2616-sec17.html#bib43\">[43]</a>. If a request is\r\n      authenticated and a realm specified, the same credentials SHOULD\r\n      be valid for all other requests within this realm (assuming that\r\n      the authentication scheme itself does not require otherwise, such\r\n      as credentials that vary according to a challenge value or using\r\n      synchronized clocks).\r\n</pre>\n<pre>      When a shared cache (see section 13.7) receives a request\r\n      containing an Authorization field, it MUST NOT return the\r\n      corresponding response as a reply to any other request, unless one\r\n      of the following specific exceptions holds:\r\n</pre>\n<pre>      1. If the response includes the \"s-maxage\" cache-control\r\n         directive, the cache MAY use that response in replying to a\r\n         subsequent request. But (if the specified maximum age has\r\n         passed) a proxy cache MUST first revalidate it with the origin\r\n         server, using the request-headers from the new request to allow\r\n         the origin server to authenticate the new request. (This is the\r\n         defined behavior for s-maxage.) If the response includes \"s-\r\n         maxage=0\", the proxy MUST always revalidate it before re-using\r\n         it.\r\n</pre>\n<pre>      2. If the response includes the \"must-revalidate\" cache-control\r\n         directive, the cache MAY use that response in replying to a\r\n         subsequent request. But if the response is stale, all caches\r\n         MUST first revalidate it with the origin server, using the\r\n         request-headers from the new request to allow the origin server\r\n         to authenticate the new request.\r\n</pre>\n<pre>      3. If the response includes the \"public\" cache-control directive,\r\n         it MAY be returned in reply to any subsequent request.\r\n</pre>","type":"REQUEST"},{"name":"Cache-Control","example":"Cache-Control: no-cache","short-description":"Set the caching rules","long-description":"<p> The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain. The directives specify behavior intended to prevent caches from adversely interfering with the request or response. These directives typically override the default caching algorithms. Cache directives are unidirectional in that the presence of a directive in a request does not imply that the same directive is to be given in the response. </p>\n<pre>      Note that HTTP/1.0 caches might not implement Cache-Control and\r\n      might only implement Pragma: no-cache (see section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.32\">14.32</a>).\r\n</pre>\n<p> Cache directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to specify a cache- directive for a specific cache. </p>\n<pre>    Cache-Control   = \"Cache-Control\" \":\" 1#cache-directive\r\n</pre>\n<pre>    cache-directive = cache-request-directive\r\n         | cache-response-directive\r\n</pre>\n<pre>    cache-request-directive =\r\n           \"no-cache\"                          ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.1\">14.9.1</a>\r\n         | \"no-store\"                          ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.2\">14.9.2</a>\r\n         | \"max-age\" \"=\" delta-seconds         ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.3\">14.9.3</a>, <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.4\">14.9.4</a>\r\n         | \"max-stale\" [ \"=\" delta-seconds ]   ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.3\">14.9.3</a>\r\n         | \"min-fresh\" \"=\" delta-seconds       ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.3\">14.9.3</a>\r\n         | \"no-transform\"                      ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.5\">14.9.5</a>\r\n         | \"only-if-cached\"                    ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.4\">14.9.4</a>\r\n         | cache-extension                     ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.6\">14.9.6</a>\r\n</pre>\n<pre>     cache-response-directive =\r\n           \"public\"                               ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.1\">14.9.1</a>\r\n         | \"private\" [ \"=\" &lt;\"&gt; 1#field-name &lt;\"&gt; ] ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.1\">14.9.1</a>\r\n         | \"no-cache\" [ \"=\" &lt;\"&gt; 1#field-name &lt;\"&gt; ]; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.1\">14.9.1</a>\r\n         | \"no-store\"                             ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.2\">14.9.2</a>\r\n         | \"no-transform\"                         ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.5\">14.9.5</a>\r\n         | \"must-revalidate\"                      ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.4\">14.9.4</a>\r\n         | \"proxy-revalidate\"                     ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.4\">14.9.4</a>\r\n         | \"max-age\" \"=\" delta-seconds            ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.3\">14.9.3</a>\r\n         | \"s-maxage\" \"=\" delta-seconds           ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.3\">14.9.3</a>\r\n         | cache-extension                        ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.6\">14.9.6</a>\r\n</pre>\n<pre>    cache-extension = token [ \"=\" ( token | quoted-string ) ]\r\n</pre>\n<p> When a directive appears without any 1#field-name parameter, the directive applies to the entire request or response. When such a directive appears with a 1#field-name parameter, it applies only to the named field or fields, and not to the rest of the request or response. This mechanism supports extensibility; implementations of future versions of the HTTP protocol might apply these directives to header fields not defined in HTTP/1.1. </p>\n<p> The cache-control directives can be broken down into these general categories: </p>\n<pre>      - Restrictions on what are cacheable; these may only be imposed by\r\n        the origin server.\r\n</pre>\n<pre>      - Restrictions on what may be stored by a cache; these may be\r\n        imposed by either the origin server or the user agent.\r\n</pre>\n<pre>      - Modifications of the basic expiration mechanism; these may be\r\n        imposed by either the origin server or the user agent.\r\n</pre>\n<pre>      - Controls over cache revalidation and reload; these may only be\r\n        imposed by a user agent.\r\n</pre>\n<pre>      - Control over transformation of entities.\r\n</pre>\n<pre>      - Extensions to the caching system.\r\n</pre>","type":"REQUEST"},{"name":"Connection","example":"Connection: keep-alive","short-description":"Control options for the current connection. Accepts keep-alive and close. Deprecated in HTTP/2","long-description":"<p> The Connection general-header field allows the sender to specify options that are desired for that particular connection and MUST NOT be communicated by proxies over further connections. </p>\n<p> The Connection header has the following grammar: </p>\n<pre>       Connection = \"Connection\" \":\" 1#(connection-token)\r\n       connection-token  = token\r\n</pre>\n<p> HTTP/1.1 proxies MUST parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header field(s) from the message with the same name as the connection-token. Connection options are signaled by the presence of a connection-token in the Connection header field, not by any corresponding additional header field(s), since the additional header field may not be sent if there are no parameters associated with that connection option. </p>\n<p> Message headers listed in the Connection header MUST NOT include end-to-end headers, such as Cache-Control. </p>\n<p> HTTP/1.1 defines the \"close\" connection option for the sender to signal that the connection will be closed after completion of the response. For example, </p>\n<pre>       Connection: close\r\n</pre>\n<p> in either the request or the response header fields indicates that the connection SHOULD NOT be considered `persistent' (section 8.1) after the current request/response is complete. </p>\n<p> HTTP/1.1 applications that do not support persistent connections MUST include the \"close\" connection option in every message. </p>\n<p> A system receiving an HTTP/1.0 (or lower-version) message that includes a Connection header MUST, for each connection-token in this field, remove and ignore any header field(s) from the message with the same name as the connection-token. This protects against mistaken forwarding of such header fields by pre-HTTP/1.1 proxies. See section <a rel=\"xref\" href=\"rfc2616-sec19.html#sec19.6.2\">19.6.2</a>. </p>","type":"REQUEST"},{"name":"Content-Length","example":"Content-Length: 348","short-description":"The length of the request body in bytes","long-description":"<p> The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. </p>\n<pre>       Content-Length    = \"Content-Length\" \":\" 1*DIGIT\r\n</pre>\n<p> An example is </p>\n<pre>       Content-Length: 3495\r\n</pre>\n<p> Applications SHOULD use this field to indicate the transfer-length of the message-body, unless this is prohibited by the rules in section <a rel=\"xref\" href=\"rfc2616-sec4.html#sec4.4\">4.4</a>. </p>\n<p> Any Content-Length greater than or equal to zero is a valid value. Section 4.4 describes how to determine the length of a message-body if a Content-Length is not given. </p>\n<p> Note that the meaning of this field is significantly different from the corresponding definition in MIME, where it is an optional field used within the \"message/external-body\" content-type. In HTTP, it SHOULD be sent whenever the message's length can be determined prior to being transferred, unless this is prohibited by the rules in section <a rel=\"xref\" href=\"rfc2616-sec4.html#sec4.4\">4.4</a>. </p>","type":"REQUEST"},{"name":"Content-Type","example":"Content-Type: application/x-www-form-urlencoded","short-description":"The content type of the body of the request (used in POST and PUT requests).","long-description":"<p> The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. </p>\n<pre>       Content-Type   = \"Content-Type\" \":\" media-type\r\n</pre>\n<p> Media types are defined in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.7\">3.7</a>. An example of the field is </p>\n<pre>       Content-Type: text/html; charset=ISO-8859-4\r\n</pre>\n<p> Further discussion of methods for identifying the media type of an entity is provided in section 7.2.1. </p>","type":"REQUEST"},{"name":"Cookie","example":"Cookie: name=value","short-description":"See more on Cookies","long-description":null,"type":"REQUEST"},{"name":"Date","example":"Date: Tue, 15 Nov 1994 08:12:31 GMT","short-description":"The date and time that the request was sent","long-description":"<p> The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822. The field value is an HTTP-date, as described in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.3.1\">3.3.1</a>; it MUST be sent in RFC 1123 <a rel=\"bibref\" href=\"rfc2616-sec17.html#bib8\">[8]</a>-date format. </p>\n<pre>       Date  = \"Date\" \":\" HTTP-date\r\n</pre>\n<p> An example is </p>\n<pre>       Date: Tue, 15 Nov 1994 08:12:31 GMT\r\n</pre>\n<p> Origin servers MUST include a Date header field in all responses, except in these cases: </p>\n<pre>      1. If the response status code is 100 (Continue) or 101 (Switching\r\n         Protocols), the response MAY include a Date header field, at\r\n         the server's option.\r\n</pre>\n<pre>      2. If the response status code conveys a server error, e.g. 500\r\n         (Internal Server Error) or 503 (Service Unavailable), and it is\r\n         inconvenient or impossible to generate a valid Date.\r\n</pre>\n<pre>      3. If the server does not have a clock that can provide a\r\n         reasonable approximation of the current time, its responses\r\n         MUST NOT include a Date header field. In this case, the rules\r\n         in section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.18.1\">14.18.1</a> MUST be followed.\r\n</pre>\n<p> A received message that does not have a Date header field MUST be assigned one by the recipient if the message will be cached by that recipient or gatewayed via a protocol which requires a Date. An HTTP implementation without a clock MUST NOT cache responses without revalidating them on every use. An HTTP cache, especially a shared cache, SHOULD use a mechanism, such as NTP <a rel=\"bibref\" href=\"rfc2616-sec17.html#bib28\">[28]</a>, to synchronize its clock with a reliable external standard. </p>\n<p> Clients SHOULD only send a Date header field in messages that include an entity-body, as in the case of the PUT and POST requests, and even then it is optional. A client without a clock MUST NOT send a Date header field in a request. </p>\n<p> The HTTP-date sent in a Date header SHOULD NOT represent a date and time subsequent to the generation of the message. It SHOULD represent the best available approximation of the date and time of message generation, unless the implementation has no means of generating a reasonably accurate date and time. In theory, the date ought to represent the moment just before the entity is generated. In practice, the date can be generated at any time during the message origination without affecting its semantic value. </p>","type":"REQUEST"},{"name":"Expect","example":"Expect: 100-continue","short-description":"Itâ€™s typically used when sending a large request body. We expect the server to return back a 100 Continue HTTP status if it can handle the request, or 417 Expectation Failed if not","long-description":"<p> The Expect request-header field is used to indicate that particular server behaviors are required by the client. </p>\n<pre>      Expect       =  \"Expect\" \":\" 1#expectation\r\n</pre>\n<pre>      expectation  =  \"100-continue\" | expectation-extension\r\n      expectation-extension =  token [ \"=\" ( token | quoted-string )\r\n                               *expect-params ]\r\n      expect-params =  \";\" token [ \"=\" ( token | quoted-string ) ]\r\n</pre>\n<p> A server that does not understand or is unable to comply with any of the expectation values in the Expect field of a request MUST respond with appropriate error status. The server MUST respond with a 417 (Expectation Failed) status if any of the expectations cannot be met or, if there are other problems with the request, some other 4xx status. </p>\n<p> This header field is defined with extensible syntax to allow for future extensions. If a server receives a request containing an Expect field that includes an expectation-extension that it does not support, it MUST respond with a 417 (Expectation Failed) status. </p>\n<p> Comparison of expectation values is case-insensitive for unquoted tokens (including the 100-continue token), and is case-sensitive for quoted-string expectation-extensions. </p>\n<p> The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST return a 417 (Expectation Failed) status if it receives a request with an expectation that it cannot meet. However, the Expect request-header itself is end-to-end; it MUST be forwarded if the request is forwarded. </p>\n<p> Many older HTTP/1.0 and HTTP/1.1 applications do not understand the Expect header. </p>\n<p> See section <a rel=\"xref\" href=\"rfc2616-sec8.html#sec8.2.3\">8.2.3</a> for the use of the 100 (continue) status. </p>","type":"REQUEST"},{"name":"Forwarded","example":"Forwarded: for=192.0.2.60; proto=http; by=203.0.113.43","short-description":"Disclose original information of a client connecting to a web server through an HTTP proxy. Used for testing purposes only, as it discloses privacy sensitive information","long-description":null,"type":"REQUEST"},{"name":"From","example":"From: user@example.com","short-description":"The email address of the user making the request. Meant to be used, for example, to indicate a contact email for bots.","long-description":"<p> The From request-header field, if given, SHOULD contain an Internet e-mail address for the human user who controls the requesting user agent. The address SHOULD be machine-usable, as defined by \"mailbox\" in RFC 822 <a rel=\"bibref\" href=\"rfc2616-sec17.html#bib9\">[9]</a> as updated by RFC 1123 <a rel=\"bibref\" href=\"rfc2616-sec17.html#bib8\">[8]</a>: </p>\n<pre>       From   = \"From\" \":\" mailbox\r\n</pre>\n<p> An example is: </p>\n<pre>       From: webmaster@w3.org\r\n</pre>\n<p> This header field MAY be used for logging purposes and as a means for identifying the source of invalid or unwanted requests. It SHOULD NOT be used as an insecure form of access protection. The interpretation of this field is that the request is being performed on behalf of the person given, who accepts responsibility for the method performed. In particular, robot agents SHOULD include this header so that the person responsible for running the robot can be contacted if problems occur on the receiving end. </p>\n<p> The Internet e-mail address in this field MAY be separate from the Internet host which issued the request. For example, when a request is passed through a proxy the original issuer's address SHOULD be used. </p>\n<p> The client SHOULD NOT send the From header field without the user's approval, as it might conflict with the user's privacy interests or their site's security policy. It is strongly recommended that the user be able to disable, enable, and modify the value of this field at any time prior to a request. </p>","type":"REQUEST"},{"name":"Host","example":"Host: flaviocopes.com","short-description":"The domain name of the server (used to determined the server with virtual hosting), and the TCP port number on which the server is listening. If the port is omitted, 80 is assumed. This is a mandatory HTTP request header","long-description":"<p> The Host request-header field specifies the Internet host and port number of the resource being requested, as obtained from the original URI given by the user or referring resource (generally an HTTP URL, </p>\n<p> as described in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.2.2\">3.2.2</a>). The Host field value MUST represent the naming authority of the origin server or gateway given by the original URL. This allows the origin server or gateway to differentiate between internally-ambiguous URLs, such as the root \"/\" URL of a server for multiple host names on a single IP address. </p>\n<pre>       Host = \"Host\" \":\" host [ \":\" port ] ; Section 3.2.2\r\n</pre>\n<p> A \"host\" without any trailing port information implies the default port for the service requested (e.g., \"80\" for an HTTP URL). For example, a request on the origin server for &lt;http://www.w3.org/pub/WWW/&gt; would properly include: </p>\n<pre>       GET /pub/WWW/ HTTP/1.1\r\n       Host: www.w3.org\r\n</pre>\n<p> A client MUST include a Host header field in all HTTP/1.1 request messages . If the requested URI does not include an Internet host name for the service being requested, then the Host header field MUST be given with an empty value. An HTTP/1.1 proxy MUST ensure that any request message it forwards does contain an appropriate Host header field that identifies the service being requested by the proxy. All Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message which lacks a Host header field. </p>\n<p> See sections <a rel=\"xref\" href=\"rfc2616-sec5.html#sec5.2\">5.2</a> and <a rel=\"xref\" href=\"rfc2616-sec19.html#sec19.6.1.1\">19.6.1.1</a> for other requirements relating to Host. </p>","type":"REQUEST"},{"name":"If-Match","example":"If-Match: \"737060cd8c284d8582d\"","short-description":"Given one (or more) ETags, the server should only send back the response if the current resource matches one of those ETags. Mainly used in PUT methods to update a resource only if it has not been modified since the user last updated it","long-description":"<p> The If-Match request-header field is used with a method to make it conditional. A client that has one or more entities previously obtained from the resource can verify that one of those entities is current by including a list of their associated entity tags in the If-Match header field. Entity tags are defined in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.11\">3.11</a>. The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead. It is also used, on updating requests, to prevent inadvertent modification of the wrong version of a resource. As a special case, the value \"*\" matches any current entity of the resource. </p>\n<pre>       If-Match = \"If-Match\" \":\" ( \"*\" | 1#entity-tag )\r\n</pre>\n<p> If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-Match header) on that resource, or if \"*\" is given </p>\n<p> and any current entity exists for that resource, then the server MAY perform the requested method as if the If-Match header field did not exist. </p>\n<p> A server MUST use the strong comparison function (see section <a rel=\"xref\" href=\"rfc2616-sec13.html#sec13.3.3\">13.3.3</a>) to compare the entity tags in If-Match. </p>\n<p> If none of the entity tags match, or if \"*\" is given and no current entity exists, the server MUST NOT perform the requested method, and MUST return a 412 (Precondition Failed) response. This behavior is most useful when the client wants to prevent an updating method, such as PUT, from modifying a resource that has changed since the client last retrieved it. </p>\n<p> If the request would, without the If-Match header field, result in anything other than a 2xx or 412 status, then the If-Match header MUST be ignored. </p>\n<p> The meaning of \"If-Match: *\" is that the method SHOULD be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.44\">14.44</a>) exists, and MUST NOT be performed if the representation does not exist. </p>\n<p> A request intended to update a resource (e.g., a PUT) MAY include an If-Match header field to signal that the request method MUST NOT be applied if the entity corresponding to the If-Match value (a single entity tag) is no longer a representation of that resource. This allows the user to indicate that they do not wish the request to be successful if the resource has been changed without their knowledge. Examples: </p>\n<pre>       If-Match: \"xyzzy\"\r\n       If-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\r\n       If-Match: *\r\n</pre>\n<p> The result of a request having both an If-Match header field and either an If-None-Match or an If-Modified-Since header fields is undefined by this specification. </p>","type":"REQUEST"},{"name":"If-Modified-Since","example":"If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT","short-description":"Allows to return a 304 Not Modified response header if the content is unchanged since that date","long-description":"<p> The If-Modified-Since request-header field is used with a method to make it conditional: if the requested variant has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message-body. </p>\n<pre>       If-Modified-Since = \"If-Modified-Since\" \":\" HTTP-date\r\n</pre>\n<p> An example of the field is: </p>\n<pre>       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\r\n</pre>\n<p> A GET method with an If-Modified-Since header and no Range header requests that the identified entity be transferred only if it has been modified since the date given by the If-Modified-Since header. The algorithm for determining this includes the following cases: </p>\n<pre>      a) If the request would normally result in anything other than a\r\n         200 (OK) status, or if the passed If-Modified-Since date is\r\n         invalid, the response is exactly the same as for a normal GET.\r\n         A date which is later than the server's current time is\r\n         invalid.\r\n</pre>\n<pre>      b) If the variant has been modified since the If-Modified-Since\r\n         date, the response is exactly the same as for a normal GET.\r\n</pre>\n<pre>      c) If the variant has not been modified since a valid If-\r\n         Modified-Since date, the server SHOULD return a 304 (Not\r\n         Modified) response.\r\n</pre>\n<p> The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead. </p>\n<pre>      Note: The Range request-header field modifies the meaning of If-\r\n      Modified-Since; see section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.35\">14.35</a> for full details.\r\n</pre>\n<pre>      Note: If-Modified-Since times are interpreted by the server, whose\r\n      clock might not be synchronized with the client.\r\n</pre>\n<pre>      Note: When handling an If-Modified-Since header field, some\r\n      servers will use an exact date comparison function, rather than a\r\n      less-than function, for deciding whether to send a 304 (Not\r\n      Modified) response. To get best results when sending an If-\r\n      Modified-Since header field for cache validation, clients are\r\n      advised to use the exact date string received in a previous Last-\r\n      Modified header field whenever possible.\r\n</pre>\n<pre>      Note: If a client uses an arbitrary date in the If-Modified-Since\r\n      header instead of a date taken from the Last-Modified header for\r\n      the same request, the client should be aware of the fact that this\r\n      date is interpreted in the server's understanding of time. The\r\n      client should consider unsynchronized clocks and rounding problems\r\n      due to the different encodings of time between the client and\r\n      server. This includes the possibility of race conditions if the\r\n      document has changed between the time it was first requested and\r\n      the If-Modified-Since date of a subsequent request, and the\r\n</pre>\n<pre>      possibility of clock-skew-related problems if the If-Modified-\r\n      Since date is derived from the client's clock without correction\r\n      to the server's clock. Corrections for different time bases\r\n      between client and server are at best approximate due to network\r\n      latency.\r\n</pre>\n<p> The result of a request having both an If-Modified-Since header field and either an If-Match or an If-Unmodified-Since header fields is undefined by this specification. </p>","type":"REQUEST"},{"name":"If-None-Match","example":"If-None-Match: \"737060cd882f209582d\"","short-description":"Allows a 304 Not Modified response header to be returned if content is unchanged. Opposite of If-Match.","long-description":"<p> The If-None-Match request-header field is used with a method to make it conditional. A client that has one or more entities previously obtained from the resource can verify that none of those entities is current by including a list of their associated entity tags in the If-None-Match header field. The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead. It is also used to prevent a method (e.g. PUT) from inadvertently modifying an existing resource when the client believes that the resource does not exist. </p>\n<p> As a special case, the value \"*\" matches any current entity of the resource. </p>\n<pre>       If-None-Match = \"If-None-Match\" \":\" ( \"*\" | 1#entity-tag )\r\n</pre>\n<p> If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-None-Match header) on that resource, or if \"*\" is given and any current entity exists for that resource, then the server MUST NOT perform the requested method, unless required to do so because the resource's modification date fails to match that supplied in an If-Modified-Since header field in the request. Instead, if the request method was GET or HEAD, the server SHOULD respond with a 304 (Not Modified) response, including the cache- related header fields (particularly ETag) of one of the entities that matched. For all other request methods, the server MUST respond with a status of 412 (Precondition Failed). </p>\n<p> See section <a rel=\"xref\" href=\"rfc2616-sec13.html#sec13.3.3\">13.3.3</a> for rules on how to determine if two entities tags match. The weak comparison function can only be used with GET or HEAD requests. </p>\n<p> If none of the entity tags match, then the server MAY perform the requested method as if the If-None-Match header field did not exist, but MUST also ignore any If-Modified-Since header field(s) in the request. That is, if no entity tags match, then the server MUST NOT return a 304 (Not Modified) response. </p>\n<p> If the request would, without the If-None-Match header field, result in anything other than a 2xx or 304 status, then the If-None-Match header MUST be ignored. (See section <a rel=\"xref\" href=\"rfc2616-sec13.html#sec13.3.4\">13.3.4</a> for a discussion of server behavior when both If-Modified-Since and If-None-Match appear in the same request.) </p>\n<p> The meaning of \"If-None-Match: *\" is that the method MUST NOT be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.44\">14.44</a>) exists, and SHOULD be performed if the representation does not exist. This feature is intended to be useful in preventing races between PUT operations. </p>\n<p> Examples: </p>\n<pre>       If-None-Match: \"xyzzy\"\r\n       If-None-Match: W/\"xyzzy\"\r\n       If-None-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\r\n       If-None-Match: W/\"xyzzy\", W/\"r2d2xxxx\", W/\"c3piozzzz\"\r\n       If-None-Match: *\r\n</pre>\n<p> The result of a request having both an If-None-Match header field and either an If-Match or an If-Unmodified-Since header fields is undefined by this specification. </p>","type":"REQUEST"},{"name":"If-Range","example":"If-Range: \"737060cd8c9582d\"","short-description":"Used to resume downloads, returns a partial if the condition is matched (ETag or date) or the full resource if not. See more","long-description":"<p> If a client has a partial copy of an entity in its cache, and wishes to have an up-to-date copy of the entire entity in its cache, it could use the Range request-header with a conditional GET (using either or both of If-Unmodified-Since and If-Match.) However, if the condition fails because the entity has been modified, the client would then have to make a second request to obtain the entire current entity-body. </p>\n<p> The If-Range header allows a client to \"short-circuit\" the second request. Informally, its meaning is `if the entity is unchanged, send me the part(s) that I am missing; otherwise, send me the entire new entity'. </p>\n<pre>        If-Range = \"If-Range\" \":\" ( entity-tag | HTTP-date )\r\n</pre>\n<p> If the client has no entity tag for an entity, but does have a Last- Modified date, it MAY use that date in an If-Range header. (The server can distinguish between a valid HTTP-date and any form of entity-tag by examining no more than two characters.) The If-Range header SHOULD only be used together with a Range header, and MUST be ignored if the request does not include a Range header, or if the server does not support the sub-range operation. </p>\n<p> If the entity tag given in the If-Range header matches the current entity tag for the entity, then the server SHOULD provide the specified sub-range of the entity using a 206 (Partial content) response. If the entity tag does not match, then the server SHOULD return the entire entity using a 200 (OK) response. </p>","type":"REQUEST"},{"name":"If-Unmodified-Since","example":"If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT","short-description":"Only send the response if the entity has not been modified since the specified time","long-description":"<p> The If-Unmodified-Since request-header field is used with a method to make it conditional. If the requested resource has not been modified since the time specified in this field, the server SHOULD perform the requested operation as if the If-Unmodified-Since header were not present. </p>\n<p> If the requested variant has been modified since the specified time, the server MUST NOT perform the requested operation, and MUST return a 412 (Precondition Failed). </p>\n<pre>      If-Unmodified-Since = \"If-Unmodified-Since\" \":\" HTTP-date\r\n</pre>\n<p> An example of the field is: </p>\n<pre>       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT\r\n</pre>\n<p> If the request normally (i.e., without the If-Unmodified-Since header) would result in anything other than a 2xx or 412 status, the If-Unmodified-Since header SHOULD be ignored. </p>\n<p> If the specified date is invalid, the header is ignored. </p>\n<p> The result of a request having both an If-Unmodified-Since header field and either an If-None-Match or an If-Modified-Since header fields is undefined by this specification. </p>","type":"REQUEST"},{"name":"Max-Forwards","example":"Max-Forwards: 10","short-description":"Limit the number of times the message can be forwarded through proxies or gateways","long-description":"<p> The Max-Forwards request-header field provides a mechanism with the TRACE (section 9.8) and OPTIONS (section 9.2) methods to limit the number of proxies or gateways that can forward the request to the next inbound server. This can be useful when the client is attempting to trace a request chain which appears to be failing or looping in mid-chain. </p>\n<pre>       Max-Forwards   = \"Max-Forwards\" \":\" 1*DIGIT\r\n</pre>\n<p> The Max-Forwards value is a decimal integer indicating the remaining number of times this request message may be forwarded. </p>\n<p> Each proxy or gateway recipient of a TRACE or OPTIONS request containing a Max-Forwards header field MUST check and update its value prior to forwarding the request. If the received value is zero (0), the recipient MUST NOT forward the request; instead, it MUST respond as the final recipient. If the received Max-Forwards value is greater than zero, then the forwarded message MUST contain an updated Max-Forwards field with a value decremented by one (1). </p>\n<p> The Max-Forwards header field MAY be ignored for all other methods defined by this specification and for any extension methods for which it is not explicitly referred to as part of that method definition. </p>","type":"REQUEST"},{"name":"Origin","example":"Origin: http://mydomain.com","short-description":"Send the current domain to perform a CORS request, used in an OPTIONS HTTP request (to ask the server for Access-Control- response headers)","long-description":null,"type":"REQUEST"},{"name":"Pragma","example":"Pragma: no-cache","short-description":"Used for backwards compatibility with HTTP/1.0 caches","long-description":"<p> The Pragma general-header field is used to include implementation- specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives. </p>\n<pre>       Pragma            = \"Pragma\" \":\" 1#pragma-directive\r\n       pragma-directive  = \"no-cache\" | extension-pragma\r\n       extension-pragma  = token [ \"=\" ( token | quoted-string ) ]\r\n</pre>\n<p> When the no-cache directive is present in a request message, an application SHOULD forward the request toward the origin server even if it has a cached copy of what is being requested. This pragma directive has the same semantics as the no-cache cache-directive (see section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9\">14.9</a>) and is defined here for backward compatibility with HTTP/1.0. Clients SHOULD include both header fields when a no-cache request is sent to a server not known to be HTTP/1.1 compliant. </p>\n<p> Pragma directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to specify a pragma for a specific recipient; however, any pragma directive not relevant to a recipient SHOULD be ignored by that recipient. </p>\n<p> HTTP/1.1 caches SHOULD treat \"Pragma: no-cache\" as if the client had sent \"Cache-Control: no-cache\". No new Pragma directives will be defined in HTTP. </p>\n<pre>      Note: because the meaning of \"Pragma: no-cache as a response\r\n      header field is not actually specified, it does not provide a\r\n      reliable replacement for \"Cache-Control: no-cache\" in a response\r\n</pre>","type":"REQUEST"},{"name":"Proxy-Authorization","example":"Proxy-Authorization: Basic 2323jiojioIJOIOJIJ==","short-description":"Authorization credentials for connecting to a proxy","long-description":"<p> The Proxy-Authorization request-header field allows the client to identify itself (or its user) to a proxy which requires authentication. The Proxy-Authorization field value consists of credentials containing the authentication information of the user agent for the proxy and/or realm of the resource being requested. </p>\n<pre>       Proxy-Authorization     = \"Proxy-Authorization\" \":\" credentials\r\n</pre>\n<p> The HTTP access authentication process is described in \"HTTP Authentication: Basic and Digest Access Authentication\" [43] . Unlike Authorization, the Proxy-Authorization header field applies only to the next outbound proxy that demanded authentication using the Proxy- Authenticate field. When multiple proxies are used in a chain, the </p>\n<p> Proxy-Authorization header field is consumed by the first outbound proxy that was expecting to receive credentials. A proxy MAY relay the credentials from the client request to the next proxy if that is the mechanism by which the proxies cooperatively authenticate a given request. </p>","type":"REQUEST"},{"name":"Range","example":"Range: bytes=500-999","short-description":"Request only a specific part of a resource","long-description":"<p> HTTP retrieval requests using conditional or unconditional GET methods MAY request one or more sub-ranges of the entity, instead of the entire entity, using the Range request header, which applies to the entity returned as the result of the request: </p>\n<pre>      Range = \"Range\" \":\" ranges-specifier\r\n</pre>\n<p> A server MAY ignore the Range header. However, HTTP/1.1 origin servers and intermediate caches ought to support byte ranges when possible, since Range supports efficient recovery from partially failed transfers, and supports efficient partial retrieval of large entities. </p>\n<p> If the server supports the Range header and the specified range or ranges are appropriate for the entity: </p>\n<pre>      - The presence of a Range header in an unconditional GET modifies\r\n        what is returned if the GET is otherwise successful. In other\r\n        words, the response carries a status code of 206 (Partial\r\n        Content) instead of 200 (OK).\r\n</pre>\n<pre>      - The presence of a Range header in a conditional GET (a request\r\n        using one or both of If-Modified-Since and If-None-Match, or\r\n        one or both of If-Unmodified-Since and If-Match) modifies what\r\n        is returned if the GET is otherwise successful and the\r\n        condition is true. It does not affect the 304 (Not Modified)\r\n        response returned if the conditional is false.\r\n</pre>\n<p> In some cases, it might be more appropriate to use the If-Range header (see section 14.27) in addition to the Range header. </p>\n<p> If a proxy that supports ranges receives a Range request, forwards the request to an inbound server, and receives an entire entity in reply, it SHOULD only return the requested range to its client. It SHOULD store the entire received response in its cache if that is consistent with its cache allocation policies. </p>","type":"REQUEST"},{"name":"Referer","example":"Referer: https://flaviocopes.com","short-description":"The address of the previous web page from which a link to the currently requested page was followed.","long-description":"<p> The Referer[sic] request-header field allows the client to specify, for the server's benefit, the address (URI) of the resource from which the Request-URI was obtained (the \"referrer\", although the header field is misspelled.) The Referer request-header allows a server to generate lists of back-links to resources for interest, logging, optimized caching, etc. It also allows obsolete or mistyped links to be traced for maintenance. The Referer field MUST NOT be sent if the Request-URI was obtained from a source that does not have its own URI, such as input from the user keyboard. </p>\n<pre>       Referer        = \"Referer\" \":\" ( absoluteURI | relativeURI )\r\n</pre>\n<p> Example: </p>\n<pre>       Referer: http://www.w3.org/hypertext/DataSources/Overview.html\r\n</pre>\n<p> If the field value is a relative URI, it SHOULD be interpreted relative to the Request-URI. The URI MUST NOT include a fragment. See section <a rel=\"xref\" href=\"rfc2616-sec15.html#sec15.1.3\">15.1.3</a> for security considerations. </p>","type":"REQUEST"},{"name":"TE","example":"TE: trailers, deflate","short-description":"Specify the encodings the client can accept. Accepted values: compress, deflate, gzip, trailers. Only trailers is supported in HTTP/2","long-description":"<p> The TE request-header field indicates what extension transfer-codings it is willing to accept in the response and whether or not it is willing to accept trailer fields in a chunked transfer-coding. Its value may consist of the keyword \"trailers\" and/or a comma-separated list of extension transfer-coding names with optional accept parameters (as described in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.6\">3.6</a>). </p>\n<pre>       TE        = \"TE\" \":\" #( t-codings )\r\n       t-codings = \"trailers\" | ( transfer-extension [ accept-params ] )\r\n</pre>\n<p> The presence of the keyword \"trailers\" indicates that the client is willing to accept trailer fields in a chunked transfer-coding, as defined in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.6.1\">3.6.1</a>. This keyword is reserved for use with transfer-coding values even though it does not itself represent a transfer-coding. </p>\n<p> Examples of its use are: </p>\n<pre>       TE: deflate\r\n       TE:\r\n       TE: trailers, deflate;q=0.5\r\n</pre>\n<p> The TE header field only applies to the immediate connection. Therefore, the keyword MUST be supplied within a Connection header field (section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.10\">14.10</a>) whenever TE is present in an HTTP/1.1 message. </p>\n<p> A server tests whether a transfer-coding is acceptable, according to a TE field, using these rules: </p>\n<pre>      1. The \"chunked\" transfer-coding is always acceptable. If the\r\n         keyword \"trailers\" is listed, the client indicates that it is\r\n         willing to accept trailer fields in the chunked response on\r\n         behalf of itself and any downstream clients. The implication is\r\n         that, if given, the client is stating that either all\r\n         downstream clients are willing to accept trailer fields in the\r\n         forwarded response, or that it will attempt to buffer the\r\n         response on behalf of downstream recipients.\r\n</pre>\n<pre>         Note: HTTP/1.1 does not define any means to limit the size of a\r\n         chunked response such that a client can be assured of buffering\r\n         the entire response.\r\n</pre>\n<pre>      2. If the transfer-coding being tested is one of the transfer-\r\n         codings listed in the TE field, then it is acceptable unless it\r\n         is accompanied by a qvalue of 0. (As defined in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.9\">3.9</a>, a\r\n         qvalue of 0 means \"not acceptable.\")\r\n</pre>\n<pre>      3. If multiple transfer-codings are acceptable, then the\r\n         acceptable transfer-coding with the highest non-zero qvalue is\r\n         preferred.  The \"chunked\" transfer-coding always has a qvalue\r\n         of 1.\r\n</pre>\n<p> If the TE field-value is empty or if no TE field is present, the only transfer-coding is \"chunked\". A message with no transfer-coding is always acceptable. </p>","type":"REQUEST"},{"name":"User-Agent","example":"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36","short-description":"The string that identifies the user agent","long-description":"<p> The User-Agent request-header field contains information about the user agent originating the request. This is for statistical purposes, the tracing of protocol violations, and automated recognition of user agents for the sake of tailoring responses to avoid particular user agent limitations. User agents SHOULD include this field with requests. The field can contain multiple product tokens (section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.8\">3.8</a>) and comments identifying the agent and any subproducts which form a significant part of the user agent. By convention, the product tokens are listed in order of their significance for identifying the application. </p>\n<pre>       User-Agent     = \"User-Agent\" \":\" 1*( product | comment )\r\n</pre>\n<p> Example: </p>\n<pre>       User-Agent: CERN-LineMode/2.15 libwww/2.17b3\r\n</pre>","type":"REQUEST"},{"name":"Upgrade","example":"Upgrade: h2c, HTTPS/1.3, IRC/6.9, RTA/x11, websocket","short-description":"Ask the server to upgrade to another protocol. Deprecated in HTTP/2","long-description":"<p> The Upgrade general-header allows the client to specify what additional communication protocols it supports and would like to use if the server finds it appropriate to switch protocols. The server MUST use the Upgrade header field within a 101 (Switching Protocols) response to indicate which protocol(s) are being switched. </p>\n<pre>       Upgrade        = \"Upgrade\" \":\" 1#product\r\n</pre>\n<p> For example, </p>\n<pre>       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\r\n</pre>\n<p> The Upgrade header field is intended to provide a simple mechanism for transition from HTTP/1.1 to some other, incompatible protocol. It does so by allowing the client to advertise its desire to use another protocol, such as a later version of HTTP with a higher major version number, even though the current request has been made using HTTP/1.1. This eases the difficult transition between incompatible protocols by allowing the client to initiate a request in the more commonly supported protocol while indicating to the server that it would like to use a \"better\" protocol if available (where \"better\" is determined by the server, possibly according to the nature of the method and/or resource being requested). </p>\n<p> The Upgrade header field only applies to switching application-layer protocols upon the existing transport-layer connection. Upgrade cannot be used to insist on a protocol change; its acceptance and use by the server is optional. The capabilities and nature of the application-layer communication after the protocol change is entirely dependent upon the new protocol chosen, although the first action after changing the protocol MUST be a response to the initial HTTP request containing the Upgrade header field. </p>\n<p> The Upgrade header field only applies to the immediate connection. Therefore, the upgrade keyword MUST be supplied within a Connection header field (section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.10\">14.10</a>) whenever Upgrade is present in an HTTP/1.1 message. </p>\n<p> The Upgrade header field cannot be used to indicate a switch to a protocol on a different connection. For that purpose, it is more appropriate to use a 301, 302, 303, or 305 redirection response. </p>\n<p> This specification only defines the protocol name \"HTTP\" for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.1\">3.1</a> and future updates to this specification. Any token can be used as a protocol name; however, it will only be useful if both the client and server associate the name with the same protocol. </p>","type":"REQUEST"},{"name":"Via","example":"Via: 1.0 fred, 1.1 example.com (Apache/1.1)","short-description":"Informs the server of proxies through which the request was sent","long-description":"<p> The Via general-header field MUST be used by gateways and proxies to indicate the intermediate protocols and recipients between the user agent and the server on requests, and between the origin server and the client on responses. It is analogous to the \"Received\" field of RFC 822 <a rel=\"bibref\" href=\"rfc2616-sec17.html#bib9\">[9]</a> and is intended to be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of all senders along the request/response chain. </p>\n<pre>      Via =  \"Via\" \":\" 1#( received-protocol received-by [ comment ] )\r\n      received-protocol = [ protocol-name \"/\" ] protocol-version\r\n      protocol-name     = token\r\n      protocol-version  = token\r\n      received-by       = ( host [ \":\" port ] ) | pseudonym\r\n      pseudonym         = token\r\n</pre>\n<p> The received-protocol indicates the protocol version of the message received by the server or client along each segment of the request/response chain. The received-protocol version is appended to the Via field value when the message is forwarded so that information about the protocol capabilities of upstream applications remains visible to all recipients. </p>\n<p> The protocol-name is optional if and only if it would be \"HTTP\". The received-by field is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, it MAY be replaced by a pseudonym. If the port is not given, it MAY be assumed to be the default port of the received-protocol. </p>\n<p> Multiple Via field values represents each proxy or gateway that has forwarded the message. Each recipient MUST append its information such that the end result is ordered according to the sequence of forwarding applications. </p>\n<p> Comments MAY be used in the Via header field to identify the software of the recipient proxy or gateway, analogous to the User-Agent and Server header fields. However, all comments in the Via field are optional and MAY be removed by any recipient prior to forwarding the message. </p>\n<p> For example, a request message could be sent from an HTTP/1.0 user agent to an internal proxy code-named \"fred\", which uses HTTP/1.1 to forward the request to a public proxy at nowhere.com, which completes the request by forwarding it to the origin server at www.ics.uci.edu. The request received by www.ics.uci.edu would then have the following Via header field: </p>\n<pre>       Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\r\n</pre>\n<p> Proxies and gateways used as a portal through a network firewall SHOULD NOT, by default, forward the names and ports of hosts within the firewall region. This information SHOULD only be propagated if explicitly enabled. If not enabled, the received-by host of any host behind the firewall SHOULD be replaced by an appropriate pseudonym for that host. </p>\n<p> For organizations that have strong privacy requirements for hiding internal structures, a proxy MAY combine an ordered subsequence of Via header field entries with identical received-protocol values into a single such entry. For example, </p>\n<pre>       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy\r\n</pre>\n<pre>        could be collapsed to\r\n</pre>\n<pre>       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy\r\n</pre>\n<p> Applications SHOULD NOT combine multiple entries unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms. Applications MUST NOT combine entries which have different received-protocol values. </p>","type":"REQUEST"},{"name":"Warning","example":"Warning: 199 Miscellaneous warning","short-description":"A general warning about possible problems with the status of the message. Accepts a special range of values.","long-description":"<p> The Warning general-header field is used to carry additional information about the status or transformation of a message which might not be reflected in the message. This information is typically used to warn about a possible lack of semantic transparency from caching operations or transformations applied to the entity body of the message. </p>\n<p> Warning headers are sent with responses using: </p>\n<pre>       Warning    = \"Warning\" \":\" 1#warning-value\r\n</pre>\n<pre>       warning-value = warn-code SP warn-agent SP warn-text\r\n                                             [SP warn-date]\r\n</pre>\n<pre>       warn-code  = 3DIGIT\r\n       warn-agent = ( host [ \":\" port ] ) | pseudonym\r\n                       ; the name or pseudonym of the server adding\r\n                       ; the Warning header, for use in debugging\r\n       warn-text  = quoted-string\r\n       warn-date  = &lt;\"&gt; HTTP-date &lt;\"&gt;\r\n</pre>\n<p> A response MAY carry more than one Warning header. </p>\n<p> The warn-text SHOULD be in a natural language and character set that is most likely to be intelligible to the human user receiving the response. This decision MAY be based on any available knowledge, such as the location of the cache or user, the Accept-Language field in a request, the Content-Language field in a response, etc. The default language is English and the default character set is ISO-8859-1. </p>\n<p> If a character set other than ISO-8859-1 is used, it MUST be encoded in the warn-text using the method described in RFC 2047 [14]. </p>\n<p> Warning headers can in general be applied to any message, however some specific warn-codes are specific to caches and can only be applied to response messages. New Warning headers SHOULD be added after any existing Warning headers. A cache MUST NOT delete any Warning header that it received with a message. However, if a cache successfully validates a cache entry, it SHOULD remove any Warning headers previously attached to that entry except as specified for </p>\n<p> specific Warning codes. It MUST then add any Warning headers received in the validating response. In other words, Warning headers are those that would be attached to the most recent relevant response. </p>\n<p> When multiple Warning headers are attached to a response, the user agent ought to inform the user of as many of them as possible, in the order that they appear in the response. If it is not possible to inform the user of all of the warnings, the user agent SHOULD follow these heuristics: </p>\n<pre>      - Warnings that appear early in the response take priority over\r\n        those appearing later in the response.\r\n</pre>\n<pre>      - Warnings in the user's preferred character set take priority\r\n        over warnings in other character sets but with identical warn-\r\n        codes and warn-agents.\r\n</pre>\n<p> Systems that generate multiple Warning headers SHOULD order them with this user agent behavior in mind. </p>\n<p> Requirements for the behavior of caches with respect to Warnings are stated in section 13.1.2. </p>\n<p> This is a list of the currently-defined warn-codes, each with a recommended warn-text in English, and a description of its meaning. </p>\n<p> 110 Response is stale MUST be included whenever the returned response is stale. </p>\n<p> 111 Revalidation failed MUST be included if a cache returns a stale response because an attempt to revalidate the response failed, due to an inability to reach the server. </p>\n<p> 112 Disconnected operation SHOULD be included if the cache is intentionally disconnected from the rest of the network for a period of time. </p>\n<p> 113 Heuristic expiration MUST be included if the cache heuristically chose a freshness lifetime greater than 24 hours and the response's age is greater than 24 hours. </p>\n<p> 199 Miscellaneous warning The warning text MAY include arbitrary information to be presented to a human user, or logged. A system receiving this warning MUST NOT take any automated action, besides presenting the warning to the user. </p>\n<p> 214 Transformation applied MUST be added by an intermediate cache or proxy if it applies any transformation changing the content-coding (as specified in the Content-Encoding header) or media-type (as specified in the Content-Type header) of the response, or the entity-body of the response, unless this Warning code already appears in the response. </p>\n<p> 299 Miscellaneous persistent warning The warning text MAY include arbitrary information to be presented to a human user, or logged. A system receiving this warning MUST NOT take any automated action. </p>\n<p> If an implementation sends a message with one or more Warning headers whose version is HTTP/1.0 or lower, then the sender MUST include in each warning-value a warn-date that matches the date in the response. </p>\n<p> If an implementation receives a message with a warning-value that includes a warn-date, and that warn-date is different from the Date value in the response, then that warning-value MUST be deleted from the message before storing, forwarding, or using it. (This prevents bad consequences of naive caching of Warning header fields.) If all of the warning-values are deleted for this reason, the Warning header MUST be deleted as well. </p>","type":"REQUEST"},{"name":"Dnt","example":"DNT: 1","short-description":"If enabled, asks servers to not track the user","long-description":null,"type":"REQUEST"},{"name":"X-Requested-With","example":"X-Requested-With: XMLHttpRequest","short-description":"Identifies XHR requests","long-description":null,"type":"REQUEST"},{"name":"X-CSRF-Token","example":"X-CSRF-Token: <TOKEN>","short-description":"Used to prevent CSRF","long-description":null,"type":"REQUEST"},{"name":"Accept-Patch","example":"Accept-Patch: text/example;charset=utf-8","short-description":"Specifies which patch document formats this server supports","long-description":null,"type":"RESPONSE"},{"name":"Accept-Ranges","example":"Accept-Ranges: bytes","short-description":"What partial content range types this server supports via byte serving","long-description":"<pre>      The Accept-Ranges response-header field allows the server to\r\n      indicate its acceptance of range requests for a resource:\r\n</pre>\n<pre>          Accept-Ranges     = \"Accept-Ranges\" \":\" acceptable-ranges\r\n          acceptable-ranges = 1#range-unit | \"none\"\r\n</pre>\n<pre>      Origin servers that accept byte-range requests MAY send\r\n</pre>\n<pre>          Accept-Ranges: bytes\r\n</pre>\n<pre>      but are not required to do so. Clients MAY generate byte-range\r\n      requests without having received this header for the resource\r\n      involved. Range units are defined in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.12\">3.12</a>.\r\n</pre>\n<pre>      Servers that do not accept any kind of range request for a\r\n      resource MAY send\r\n</pre>\n<pre>          Accept-Ranges: none\r\n</pre>\n<pre>      to advise the client not to attempt a range request.\r\n</pre>","type":"RESPONSE"},{"name":"Age","example":"Age: 12","short-description":"The age the object has been in a proxy cache in seconds","long-description":"<pre>      The Age response-header field conveys the sender's estimate of the\r\n      amount of time since the response (or its revalidation) was\r\n      generated at the origin server. A cached response is \"fresh\" if\r\n      its age does not exceed its freshness lifetime. Age values are\r\n      calculated as specified in section <a rel=\"xref\" href=\"rfc2616-sec13.html#sec13.2.3\">13.2.3</a>.\r\n</pre>\n<pre>           Age = \"Age\" \":\" age-value\r\n           age-value = delta-seconds\r\n</pre>\n<pre>      Age values are non-negative decimal integers, representing time in\r\n      seconds.\r\n</pre>\n<pre>      If a cache receives a value larger than the largest positive\r\n      integer it can represent, or if any of its age calculations\r\n      overflows, it MUST transmit an Age header with a value of\r\n      2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST\r\n      include an Age header field in every response generated from its\r\n      own cache. Caches SHOULD use an arithmetic type of at least 31\r\n      bits of range.\r\n</pre>","type":"RESPONSE"},{"name":"Allow","example":"Allow: GET, HEAD","short-description":"Valid methods for a specified resource. To be used for a 405 Method not allowed","long-description":"<pre>      The Allow entity-header field lists the set of methods supported\r\n      by the resource identified by the Request-URI. The purpose of this\r\n      field is strictly to inform the recipient of valid methods\r\n      associated with the resource. An Allow header field MUST be\r\n      present in a 405 (Method Not Allowed) response.\r\n</pre>\n<pre>          Allow   = \"Allow\" \":\" #Method\r\n</pre>\n<pre>      Example of use:\r\n</pre>\n<pre>          Allow: GET, HEAD, PUT\r\n</pre>\n<pre>      This field cannot prevent a client from trying other methods.\r\n      However, the indications given by the Allow header field value\r\n      SHOULD be followed. The actual set of allowed methods is defined\r\n      by the origin server at the time of each request.\r\n</pre>\n<pre>      The Allow header field MAY be provided with a PUT request to\r\n      recommend the methods to be supported by the new or modified\r\n      resource. The server is not required to support these methods and\r\n      SHOULD include an Allow header in the response giving the actual\r\n      supported methods.\r\n</pre>\n<pre>      A proxy MUST NOT modify the Allow header field even if it does not\r\n      understand all the methods specified, since the user agent might\r\n      have other means of communicating with the origin server.\r\n</pre>","type":"RESPONSE"},{"name":"Alt-Svc","example":"Alt-Svc: http/1.1= \"http2.example.com:8001\"; ma=7200","short-description":"A server uses â€œAlt-Svcâ€ header (meaning Alternative Services) to indicate that its resources can also be accessed at a different network location (host or port) or using a different protocol. When using HTTP/2, servers should instead send an ALTSVC frame","long-description":null,"type":"RESPONSE"},{"name":"Cache-Control","example":"Cache-Control: max-age=3600 Cache-Control: no-cache, no-store, max-age=0, must-revalidate","short-description":"If no-cache is used, the Cache-Control header can tell the browser to never use a cached version of a resource without first checking the ETag value.","long-description":"<p> The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain. The directives specify behavior intended to prevent caches from adversely interfering with the request or response. These directives typically override the default caching algorithms. Cache directives are unidirectional in that the presence of a directive in a request does not imply that the same directive is to be given in the response. </p>\n<pre>      Note that HTTP/1.0 caches might not implement Cache-Control and\r\n      might only implement Pragma: no-cache (see section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.32\">14.32</a>).\r\n</pre>\n<p> Cache directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to specify a cache- directive for a specific cache. </p>\n<pre>    Cache-Control   = \"Cache-Control\" \":\" 1#cache-directive\r\n</pre>\n<pre>    cache-directive = cache-request-directive\r\n         | cache-response-directive\r\n</pre>\n<pre>    cache-request-directive =\r\n           \"no-cache\"                          ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.1\">14.9.1</a>\r\n         | \"no-store\"                          ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.2\">14.9.2</a>\r\n         | \"max-age\" \"=\" delta-seconds         ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.3\">14.9.3</a>, <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.4\">14.9.4</a>\r\n         | \"max-stale\" [ \"=\" delta-seconds ]   ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.3\">14.9.3</a>\r\n         | \"min-fresh\" \"=\" delta-seconds       ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.3\">14.9.3</a>\r\n         | \"no-transform\"                      ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.5\">14.9.5</a>\r\n         | \"only-if-cached\"                    ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.4\">14.9.4</a>\r\n         | cache-extension                     ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.6\">14.9.6</a>\r\n</pre>\n<pre>     cache-response-directive =\r\n           \"public\"                               ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.1\">14.9.1</a>\r\n         | \"private\" [ \"=\" &lt;\"&gt; 1#field-name &lt;\"&gt; ] ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.1\">14.9.1</a>\r\n         | \"no-cache\" [ \"=\" &lt;\"&gt; 1#field-name &lt;\"&gt; ]; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.1\">14.9.1</a>\r\n         | \"no-store\"                             ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.2\">14.9.2</a>\r\n         | \"no-transform\"                         ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.5\">14.9.5</a>\r\n         | \"must-revalidate\"                      ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.4\">14.9.4</a>\r\n         | \"proxy-revalidate\"                     ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.4\">14.9.4</a>\r\n         | \"max-age\" \"=\" delta-seconds            ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.3\">14.9.3</a>\r\n         | \"s-maxage\" \"=\" delta-seconds           ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.3\">14.9.3</a>\r\n         | cache-extension                        ; Section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.6\">14.9.6</a>\r\n</pre>\n<pre>    cache-extension = token [ \"=\" ( token | quoted-string ) ]\r\n</pre>\n<p> When a directive appears without any 1#field-name parameter, the directive applies to the entire request or response. When such a directive appears with a 1#field-name parameter, it applies only to the named field or fields, and not to the rest of the request or response. This mechanism supports extensibility; implementations of future versions of the HTTP protocol might apply these directives to header fields not defined in HTTP/1.1. </p>\n<p> The cache-control directives can be broken down into these general categories: </p>\n<pre>      - Restrictions on what are cacheable; these may only be imposed by\r\n        the origin server.\r\n</pre>\n<pre>      - Restrictions on what may be stored by a cache; these may be\r\n        imposed by either the origin server or the user agent.\r\n</pre>\n<pre>      - Modifications of the basic expiration mechanism; these may be\r\n        imposed by either the origin server or the user agent.\r\n</pre>\n<pre>      - Controls over cache revalidation and reload; these may only be\r\n        imposed by a user agent.\r\n</pre>\n<pre>      - Control over transformation of entities.\r\n</pre>\n<pre>      - Extensions to the caching system.\r\n</pre>","type":"RESPONSE"},{"name":"Connection","example":"Connection: close","short-description":"Control options for the current connection and list of hop-by-hop response fields. Deprecated in HTTP/2","long-description":"<p> The Connection general-header field allows the sender to specify options that are desired for that particular connection and MUST NOT be communicated by proxies over further connections. </p>\n<p> The Connection header has the following grammar: </p>\n<pre>       Connection = \"Connection\" \":\" 1#(connection-token)\r\n       connection-token  = token\r\n</pre>\n<p> HTTP/1.1 proxies MUST parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header field(s) from the message with the same name as the connection-token. Connection options are signaled by the presence of a connection-token in the Connection header field, not by any corresponding additional header field(s), since the additional header field may not be sent if there are no parameters associated with that connection option. </p>\n<p> Message headers listed in the Connection header MUST NOT include end-to-end headers, such as Cache-Control. </p>\n<p> HTTP/1.1 defines the \"close\" connection option for the sender to signal that the connection will be closed after completion of the response. For example, </p>\n<pre>       Connection: close\r\n</pre>\n<p> in either the request or the response header fields indicates that the connection SHOULD NOT be considered `persistent' (section 8.1) after the current request/response is complete. </p>\n<p> HTTP/1.1 applications that do not support persistent connections MUST include the \"close\" connection option in every message. </p>\n<p> A system receiving an HTTP/1.0 (or lower-version) message that includes a Connection header MUST, for each connection-token in this field, remove and ignore any header field(s) from the message with the same name as the connection-token. This protects against mistaken forwarding of such header fields by pre-HTTP/1.1 proxies. See section <a rel=\"xref\" href=\"rfc2616-sec19.html#sec19.6.2\">19.6.2</a>. </p>","type":"RESPONSE"},{"name":"Content-Disposition","example":"Content-Disposition: attachment; filename=\"file.txt\"","short-description":"An opportunity to raise a â€œFile Downloadâ€ dialogue box for a known MIME type with binary format or suggest a filename for dynamic content. Quotes are necessary with special characters","long-description":null,"type":"RESPONSE"},{"name":"Content-Encoding","example":"Content-Encoding: gzip","short-description":"The type of encoding used on the data. See HTTP compression","long-description":"<p> The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. Content-Encoding is primarily used to allow a document to be compressed without losing the identity of its underlying media type. </p>\n<pre>       Content-Encoding  = \"Content-Encoding\" \":\" 1#content-coding\r\n</pre>\n<p> Content codings are defined in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.5\">3.5</a>. An example of its use is </p>\n<pre>       Content-Encoding: gzip\r\n</pre>\n<p> The content-coding is a characteristic of the entity identified by the Request-URI. Typically, the entity-body is stored with this encoding and is only decoded before rendering or analogous usage. However, a non-transparent proxy MAY modify the content-coding if the new coding is known to be acceptable to the recipient, unless the \"no-transform\" cache-control directive is present in the message. </p>\n<p> If the content-coding of an entity is not \"identity\", then the response MUST include a Content-Encoding entity-header (section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.11\">14.11</a>) that lists the non-identity content-coding(s) used. </p>\n<p> If the content-coding of an entity in a request message is not acceptable to the origin server, the server SHOULD respond with a status code of 415 (Unsupported Media Type). </p>\n<p> If multiple encodings have been applied to an entity, the content codings MUST be listed in the order in which they were applied. Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification. </p>","type":"RESPONSE"},{"name":"Content-Language","example":"Content-Language: en","short-description":"The natural language or languages of the intended audience for the enclosed content","long-description":"<p> The Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body. </p>\n<pre>       Content-Language  = \"Content-Language\" \":\" 1#language-tag\r\n</pre>\n<p> Language tags are defined in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.10\">3.10</a>. The primary purpose of Content-Language is to allow a user to identify and differentiate entities according to the user's own preferred language. Thus, if the body content is intended only for a Danish-literate audience, the appropriate field is </p>\n<pre>       Content-Language: da\r\n</pre>\n<p> If no Content-Language is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended. </p>\n<p> Multiple languages MAY be listed for content that is intended for multiple audiences. For example, a rendition of the \"Treaty of Waitangi,\" presented simultaneously in the original Maori and English versions, would call for </p>\n<pre>       Content-Language: mi, en\r\n</pre>\n<p> However, just because multiple languages are present within an entity does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as \"A First Lesson in Latin,\" which is clearly intended to be used by an English-literate audience. In this case, the Content-Language would properly only include \"en\". </p>\n<p> Content-Language MAY be applied to any media type -- it is not limited to textual documents. </p>","type":"RESPONSE"},{"name":"Content-Length","example":"Content-Length: 348","short-description":"The length of the response body expressed in 8-bit bytes","long-description":"<p> The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. </p>\n<pre>       Content-Length    = \"Content-Length\" \":\" 1*DIGIT\r\n</pre>\n<p> An example is </p>\n<pre>       Content-Length: 3495\r\n</pre>\n<p> Applications SHOULD use this field to indicate the transfer-length of the message-body, unless this is prohibited by the rules in section <a rel=\"xref\" href=\"rfc2616-sec4.html#sec4.4\">4.4</a>. </p>\n<p> Any Content-Length greater than or equal to zero is a valid value. Section 4.4 describes how to determine the length of a message-body if a Content-Length is not given. </p>\n<p> Note that the meaning of this field is significantly different from the corresponding definition in MIME, where it is an optional field used within the \"message/external-body\" content-type. In HTTP, it SHOULD be sent whenever the message's length can be determined prior to being transferred, unless this is prohibited by the rules in section <a rel=\"xref\" href=\"rfc2616-sec4.html#sec4.4\">4.4</a>. </p>","type":"RESPONSE"},{"name":"Content-Location","example":"Content-Location: /index.htm","short-description":"An alternate location for the returned data","long-description":"<p> The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource's URI. A server SHOULD provide a Content-Location for the variant corresponding to the response entity; especially in the case where a resource has multiple entities associated with it, and those entities actually have separate locations by which they might be individually accessed, the server SHOULD provide a Content-Location for the particular variant which is returned. </p>\n<pre>       Content-Location = \"Content-Location\" \":\"\r\n                         ( absoluteURI | relativeURI )\r\n</pre>\n<p> The value of Content-Location also defines the base URI for the entity. </p>\n<p> The Content-Location value is not a replacement for the original requested URI; it is only a statement of the location of the resource corresponding to this particular entity at the time of the request. Future requests MAY specify the Content-Location URI as the request- URI if the desire is to identify the source of that particular entity. </p>\n<p> A cache cannot assume that an entity with a Content-Location different from the URI used to retrieve it can be used to respond to later requests on that Content-Location URI. However, the Content- Location can be used to differentiate between multiple entities retrieved from a single requested resource, as described in section <a rel=\"xref\" href=\"rfc2616-sec13.html#sec13.6\">13.6</a>. </p>\n<p> If the Content-Location is a relative URI, the relative URI is interpreted relative to the Request-URI. </p>\n<p> The meaning of the Content-Location header in PUT or POST requests is undefined; servers are free to ignore it in those cases. </p>","type":"RESPONSE"},{"name":"Content-Range","example":"Content-Range: bytes 21010-47021/47022","short-description":"Where in a full body message this partial message belongs","long-description":"<p> The Content-Range entity-header is sent with a partial entity-body to specify where in the full entity-body the partial body should be applied. Range units are defined in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.12\">3.12</a>. </p>\n<pre>       Content-Range = \"Content-Range\" \":\" content-range-spec\r\n</pre>\n<pre>       content-range-spec      = byte-content-range-spec\r\n       byte-content-range-spec = bytes-unit SP\r\n                                 byte-range-resp-spec \"/\"\r\n                                 ( instance-length | \"*\" )\r\n</pre>\n<pre>       byte-range-resp-spec = (first-byte-pos \"-\" last-byte-pos)\r\n                                      | \"*\"\r\n       instance-length           = 1*DIGIT\r\n</pre>\n<p> The header SHOULD indicate the total length of the full entity-body, unless this length is unknown or difficult to determine. The asterisk \"*\" character means that the instance-length is unknown at the time when the response was generated. </p>\n<p> Unlike byte-ranges-specifier values (see section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.35.1\">14.35.1</a>), a byte- range-resp-spec MUST only specify one range, and MUST contain absolute byte positions for both the first and last byte of the range. </p>\n<p> A byte-content-range-spec with a byte-range-resp-spec whose last- byte-pos value is less than its first-byte-pos value, or whose instance-length value is less than or equal to its last-byte-pos value, is invalid. The recipient of an invalid byte-content-range- spec MUST ignore it and any content transferred along with it. </p>\n<p> A server sending a response with status code 416 (Requested range not satisfiable) SHOULD include a Content-Range field with a byte-range- resp-spec of \"*\". The instance-length specifies the current length of </p>\n<p> the selected resource. A response with status code 206 (Partial Content) MUST NOT include a Content-Range field with a byte-range- resp-spec of \"*\". </p>\n<p> Examples of byte-content-range-spec values, assuming that the entity contains a total of 1234 bytes: </p>\n<pre>      . The first 500 bytes:\r\n       bytes 0-499/1234\r\n</pre>\n<pre>      . The second 500 bytes:\r\n       bytes 500-999/1234\r\n</pre>\n<pre>      . All except for the first 500 bytes:\r\n       bytes 500-1233/1234\r\n</pre>\n<pre>      . The last 500 bytes:\r\n       bytes 734-1233/1234\r\n</pre>\n<p> When an HTTP message includes the content of a single range (for example, a response to a request for a single range, or to a request for a set of ranges that overlap without any holes), this content is transmitted with a Content-Range header, and a Content-Length header showing the number of bytes actually transferred. For example, </p>\n<pre>       HTTP/1.1 206 Partial content\r\n       Date: Wed, 15 Nov 1995 06:25:24 GMT\r\n       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT\r\n       Content-Range: bytes 21010-47021/47022\r\n       Content-Length: 26012\r\n       Content-Type: image/gif\r\n</pre>\n<p> When an HTTP message includes the content of multiple ranges (for example, a response to a request for multiple non-overlapping ranges), these are transmitted as a multipart message. The multipart media type used for this purpose is \"multipart/byteranges\" as defined in appendix <a rel=\"xref\" href=\"rfc2616-sec19.html#sec19.2\">19.2</a>. See appendix <a rel=\"xref\" href=\"rfc2616-sec19.html#sec19.6.3\">19.6.3</a> for a compatibility issue. </p>\n<p> A response to a request for a single range MUST NOT be sent using the multipart/byteranges media type. A response to a request for multiple ranges, whose result is a single range, MAY be sent as a multipart/byteranges media type with one part. A client that cannot decode a multipart/byteranges message MUST NOT ask for multiple byte-ranges in a single request. </p>\n<p> When a client requests multiple byte-ranges in one request, the server SHOULD return them in the order that they appeared in the request. </p>\n<p> If the server ignores a byte-range-spec because it is syntactically invalid, the server SHOULD treat the request as if the invalid Range header field did not exist. (Normally, this means return a 200 response containing the full entity). </p>\n<p> If the server receives a request (other than one including an If- Range request-header field) with an unsatisfiable Range request- header field (that is, all of whose byte-range-spec values have a first-byte-pos value greater than the current length of the selected resource), it SHOULD return a response code of 416 (Requested range not satisfiable) (section <a rel=\"xref\" href=\"rfc2616-sec10.html#sec10.4.17\">10.4.17</a>). </p>\n<pre>      Note: clients cannot depend on servers to send a 416 (Requested\r\n      range not satisfiable) response instead of a 200 (OK) response for\r\n      an unsatisfiable Range request-header, since not all servers\r\n      implement this request-header.\r\n</pre>","type":"RESPONSE"},{"name":"Content-Type","example":"Content-Type: text/html; charset=utf-8","short-description":"The MIME type of this content","long-description":"<p> The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. </p>\n<pre>       Content-Type   = \"Content-Type\" \":\" media-type\r\n</pre>\n<p> Media types are defined in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.7\">3.7</a>. An example of the field is </p>\n<pre>       Content-Type: text/html; charset=ISO-8859-4\r\n</pre>\n<p> Further discussion of methods for identifying the media type of an entity is provided in section 7.2.1. </p>","type":"RESPONSE"},{"name":"Date","example":"Date: Tue, 15 Nov 1994 08:12:31 GMT","short-description":"The date and time that the message was sent (in â€œHTTP-dateâ€ format as defined by RFC 7231)","long-description":"<p> The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822. The field value is an HTTP-date, as described in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.3.1\">3.3.1</a>; it MUST be sent in RFC 1123 <a rel=\"bibref\" href=\"rfc2616-sec17.html#bib8\">[8]</a>-date format. </p>\n<pre>       Date  = \"Date\" \":\" HTTP-date\r\n</pre>\n<p> An example is </p>\n<pre>       Date: Tue, 15 Nov 1994 08:12:31 GMT\r\n</pre>\n<p> Origin servers MUST include a Date header field in all responses, except in these cases: </p>\n<pre>      1. If the response status code is 100 (Continue) or 101 (Switching\r\n         Protocols), the response MAY include a Date header field, at\r\n         the server's option.\r\n</pre>\n<pre>      2. If the response status code conveys a server error, e.g. 500\r\n         (Internal Server Error) or 503 (Service Unavailable), and it is\r\n         inconvenient or impossible to generate a valid Date.\r\n</pre>\n<pre>      3. If the server does not have a clock that can provide a\r\n         reasonable approximation of the current time, its responses\r\n         MUST NOT include a Date header field. In this case, the rules\r\n         in section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.18.1\">14.18.1</a> MUST be followed.\r\n</pre>\n<p> A received message that does not have a Date header field MUST be assigned one by the recipient if the message will be cached by that recipient or gatewayed via a protocol which requires a Date. An HTTP implementation without a clock MUST NOT cache responses without revalidating them on every use. An HTTP cache, especially a shared cache, SHOULD use a mechanism, such as NTP <a rel=\"bibref\" href=\"rfc2616-sec17.html#bib28\">[28]</a>, to synchronize its clock with a reliable external standard. </p>\n<p> Clients SHOULD only send a Date header field in messages that include an entity-body, as in the case of the PUT and POST requests, and even then it is optional. A client without a clock MUST NOT send a Date header field in a request. </p>\n<p> The HTTP-date sent in a Date header SHOULD NOT represent a date and time subsequent to the generation of the message. It SHOULD represent the best available approximation of the date and time of message generation, unless the implementation has no means of generating a reasonably accurate date and time. In theory, the date ought to represent the moment just before the entity is generated. In practice, the date can be generated at any time during the message origination without affecting its semantic value. </p>","type":"RESPONSE"},{"name":"Delta-Base","example":"Delta-Base: \"abc\"","short-description":"Specifies the delta-encoding entity tag of the response","long-description":null,"type":"RESPONSE"},{"name":"ETag","example":"ETag: \"737060cd8c284d8a[...]\"","short-description":"An identifier for a specific version of a resource, often a message digest","long-description":"<p> The ETag response-header field provides the current value of the entity tag for the requested variant. The headers used with entity tags are described in sections <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.24\">14.24</a>, <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.26\">14.26</a> and <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.44\">14.44</a>. The entity tag MAY be used for comparison with other entities from the same resource (see section <a rel=\"xref\" href=\"rfc2616-sec13.html#sec13.3.3\">13.3.3</a>). </p>\n<pre>      ETag = \"ETag\" \":\" entity-tag\r\n</pre>\n<p> Examples: </p>\n<pre>      ETag: \"xyzzy\"\r\n      ETag: W/\"xyzzy\"\r\n      ETag: \"\"\r\n</pre>","type":"RESPONSE"},{"name":"Expires","example":"Expires: Sat, 01 Dec 2018 16:00:00 GMT","short-description":"Gives the date/time after which the response is considered stale (in â€œHTTP-dateâ€ format as defined by RFC 7231)","long-description":"<p> The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache (either a proxy cache or a user agent cache) unless it is first validated with the origin server (or with an intermediate cache that has a fresh copy of the entity). See section <a rel=\"xref\" href=\"rfc2616-sec13.html#sec13.2\">13.2</a> for further discussion of the expiration model. </p>\n<p> The presence of an Expires field does not imply that the original resource will change or cease to exist at, before, or after that time. </p>\n<p> The format is an absolute date and time as defined by HTTP-date in section 3.3.1; it MUST be in RFC 1123 date format: </p>\n<pre>      Expires = \"Expires\" \":\" HTTP-date\r\n</pre>\n<p> An example of its use is </p>\n<pre>      Expires: Thu, 01 Dec 1994 16:00:00 GMT\r\n</pre>\n<pre>      Note: if a response includes a Cache-Control field with the max-\r\n      age directive (see section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9.3\">14.9.3</a>), that directive overrides the\r\n      Expires field.\r\n</pre>\n<p> HTTP/1.1 clients and caches MUST treat other invalid date formats, especially including the value \"0\", as in the past (i.e., \"already expired\"). </p>\n<p> To mark a response as \"already expired,\" an origin server sends an Expires date that is equal to the Date header value. (See the rules for expiration calculations in section <a rel=\"xref\" href=\"rfc2616-sec13.html#sec13.2.4\">13.2.4</a>.) </p>\n<p> To mark a response as \"never expires,\" an origin server sends an Expires date approximately one year from the time the response is sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one year in the future. </p>\n<p> The presence of an Expires header field with a date value of some time in the future on a response that otherwise would by default be non-cacheable indicates that the response is cacheable, unless indicated otherwise by a Cache-Control header field (section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9\">14.9</a>). </p>","type":"RESPONSE"},{"name":"IM","example":"IM: feed","short-description":"Instance-manipulations applied to the response","long-description":null,"type":"RESPONSE"},{"name":"Last-Modified","example":"Last-Modified: Mon, 15 Nov 2017 12:00:00 GMT","short-description":"The last modified date for the requested object (in â€œHTTP-dateâ€ format as defined by RFC 7231)","long-description":"<p> The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified. </p>\n<pre>       Last-Modified  = \"Last-Modified\" \":\" HTTP-date\r\n</pre>\n<p> An example of its use is </p>\n<pre>       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT\r\n</pre>\n<p> The exact meaning of this header field depends on the implementation of the origin server and the nature of the original resource. For files, it may be just the file system last-modified time. For entities with dynamically included parts, it may be the most recent of the set of last-modify times for its component parts. For database gateways, it may be the last-update time stamp of the record. For virtual objects, it may be the last time the internal state changed. </p>\n<p> An origin server MUST NOT send a Last-Modified date which is later than the server's time of message origination. In such cases, where the resource's last modification would indicate some time in the future, the server MUST replace that date with the message origination date. </p>\n<p> An origin server SHOULD obtain the Last-Modified value of the entity as close as possible to the time that it generates the Date value of its response. This allows a recipient to make an accurate assessment of the entity's modification time, especially if the entity changes near the time that the response is generated. </p>\n<p> HTTP/1.1 servers SHOULD send Last-Modified whenever feasible. </p>","type":"RESPONSE"},{"name":"Link","example":"Link: </feed>; rel=\"alternate\"","short-description":"Used to express a typed relationship with another resource, where the relation type is defined by RFC 5988","long-description":null,"type":"RESPONSE"},{"name":"Location","example":"Location: /pub/WWW/People.html","short-description":"Used in redirection, or when a new resource has been created","long-description":"<p> The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. For 201 (Created) responses, the Location is that of the new resource which was created by the request. For 3xx responses, the location SHOULD indicate the server's preferred URI for automatic redirection to the resource. The field value consists of a single absolute URI. </p>\n<pre>       Location       = \"Location\" \":\" absoluteURI\r\n</pre>\n<p> An example is: </p>\n<pre>       Location: http://www.w3.org/pub/WWW/People.html\r\n</pre>\n<pre>      Note: The Content-Location header field (section 14.14) differs\r\n      from Location in that the Content-Location identifies the original\r\n      location of the entity enclosed in the request. It is therefore\r\n      possible for a response to contain header fields for both Location\r\n      and Content-Location. Also see section <a rel=\"xref\" href=\"rfc2616-sec13.html#sec13.10\">13.10</a> for cache\r\n      requirements of some methods.\r\n</pre>","type":"RESPONSE"},{"name":"Pragma","example":"Pragma: no-cache","short-description":"Implementation-specific fields that may have various effects anywhere along the request-response chain.","long-description":"<p> The Pragma general-header field is used to include implementation- specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives. </p>\n<pre>       Pragma            = \"Pragma\" \":\" 1#pragma-directive\r\n       pragma-directive  = \"no-cache\" | extension-pragma\r\n       extension-pragma  = token [ \"=\" ( token | quoted-string ) ]\r\n</pre>\n<p> When the no-cache directive is present in a request message, an application SHOULD forward the request toward the origin server even if it has a cached copy of what is being requested. This pragma directive has the same semantics as the no-cache cache-directive (see section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.9\">14.9</a>) and is defined here for backward compatibility with HTTP/1.0. Clients SHOULD include both header fields when a no-cache request is sent to a server not known to be HTTP/1.1 compliant. </p>\n<p> Pragma directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to specify a pragma for a specific recipient; however, any pragma directive not relevant to a recipient SHOULD be ignored by that recipient. </p>\n<p> HTTP/1.1 caches SHOULD treat \"Pragma: no-cache\" as if the client had sent \"Cache-Control: no-cache\". No new Pragma directives will be defined in HTTP. </p>\n<pre>      Note: because the meaning of \"Pragma: no-cache as a response\r\n      header field is not actually specified, it does not provide a\r\n      reliable replacement for \"Cache-Control: no-cache\" in a response\r\n</pre>","type":"RESPONSE"},{"name":"Proxy-Authenticate","example":"Proxy-Authenticate: Basic","short-description":"Request authentication to access the proxy","long-description":"<p> The Proxy-Authenticate response-header field MUST be included as part of a 407 (Proxy Authentication Required) response. The field value consists of a challenge that indicates the authentication scheme and parameters applicable to the proxy for this Request-URI. </p>\n<pre>       Proxy-Authenticate  = \"Proxy-Authenticate\" \":\" 1#challenge\r\n</pre>\n<p> The HTTP access authentication process is described in \"HTTP Authentication: Basic and Digest Access Authentication\" [43]. Unlike WWW-Authenticate, the Proxy-Authenticate header field applies only to the current connection and SHOULD NOT be passed on to downstream clients. However, an intermediate proxy might need to obtain its own credentials by requesting them from the downstream client, which in some circumstances will appear as if the proxy is forwarding the Proxy-Authenticate header field. </p>","type":"RESPONSE"},{"name":"Public-Key-Pins","example":"HTTP Public Key Pinning, announces hash of websiteâ€™s authentic TLS certificate","short-description":"Retry-After","long-description":null,"type":"RESPONSE"},{"name":"Retry-After","example":"Retry-After: 120 Retry-After: Fri, 07 Nov 2014 23:59:59 GMT","short-description":"If an entity is temporarily unavailable, this instructs the client to try again later. Value could be a specified period of time (in seconds) or a HTTP-date","long-description":"<p> The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client. This field MAY also be used with any 3xx (Redirection) response to indicate the minimum time the user-agent is asked wait before issuing the redirected request. The value of this field can be either an HTTP-date or an integer number of seconds (in decimal) after the time of the response. </p>\n<pre>       Retry-After  = \"Retry-After\" \":\" ( HTTP-date | delta-seconds )\r\n</pre>\n<p> Two examples of its use are </p>\n<pre>       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT\r\n       Retry-After: 120\r\n</pre>\n<p> In the latter example, the delay is 2 minutes. </p>","type":"RESPONSE"},{"name":"Server","example":"Server: Apache/2.4.1 (Unix)","short-description":"A name for the server","long-description":"<p> The Server response-header field contains information about the software used by the origin server to handle the request. The field can contain multiple product tokens (section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.8\">3.8</a>) and comments identifying the server and any significant subproducts. The product tokens are listed in order of their significance for identifying the application. </p>\n<pre>       Server         = \"Server\" \":\" 1*( product | comment )\r\n</pre>\n<p> Example: </p>\n<pre>       Server: CERN/3.0 libwww/2.17\r\n</pre>\n<p> If the response is being forwarded through a proxy, the proxy application MUST NOT modify the Server response-header. Instead, it SHOULD include a Via field (as described in section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.45\">14.45</a>). </p>\n<pre>      Note: Revealing the specific software version of the server might\r\n      allow the server machine to become more vulnerable to attacks\r\n      against software that is known to contain security holes. Server\r\n      implementors are encouraged to make this field a configurable\r\n      option.\r\n</pre>","type":"RESPONSE"},{"name":"Set-Cookie","example":"Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1","short-description":"An HTTP cookie","long-description":null,"type":"RESPONSE"},{"name":"Strict-Transport-Security","example":"Strict-Transport-Security: max-age=16070400; includeSubDomains","short-description":"A HSTS Policy informing the HTTP client how long to cache the HTTPS only policy and whether this applies to subdomains","long-description":null,"type":"RESPONSE"},{"name":"Trailer","example":"Trailer: Max-Forwards","short-description":"The Trailer general field value indicates that the given set of header fields is present in the trailer of a message encoded with chunked transfer coding","long-description":"<p> The Trailer general field value indicates that the given set of header fields is present in the trailer of a message encoded with chunked transfer-coding. </p>\n<pre>       Trailer  = \"Trailer\" \":\" 1#field-name\r\n</pre>\n<p> An HTTP/1.1 message SHOULD include a Trailer header field in a message using chunked transfer-coding with a non-empty trailer. Doing so allows the recipient to know which header fields to expect in the trailer. </p>\n<p> If no Trailer header field is present, the trailer SHOULD NOT include any header fields. See section 3.6.1 for restrictions on the use of trailer fields in a \"chunked\" transfer-coding. </p>\n<p> Message header fields listed in the Trailer header field MUST NOT include the following header fields: </p>\n<pre>      . Transfer-Encoding\r\n</pre>\n<pre>      . Content-Length\r\n</pre>\n<pre>      . Trailer\r\n</pre>","type":"RESPONSE"},{"name":"Transfer-Encoding","example":"Transfer-Encoding: chunked","short-description":"The form of encoding used to safely transfer the entity to the user. Currently defined methods are: chunked, compress, deflate, gzip, identity. Deprecated in HTTP/2","long-description":"<p> The Transfer-Encoding general-header field indicates what (if any) type of transformation has been applied to the message body in order to safely transfer it between the sender and the recipient. This differs from the content-coding in that the transfer-coding is a property of the message, not of the entity. </p>\n<pre>     Transfer-Encoding       = \"Transfer-Encoding\" \":\" 1#transfer-coding\r\n</pre>\n<p> Transfer-codings are defined in section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.6\">3.6</a>. An example is: </p>\n<pre>     Transfer-Encoding: chunked\r\n</pre>\n<p> If multiple encodings have been applied to an entity, the transfer- codings MUST be listed in the order in which they were applied. Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification. </p>\n<p> Many older HTTP/1.0 applications do not understand the Transfer- Encoding header. </p>","type":"RESPONSE"},{"name":"Tk","example":"Tk: ?","short-description":"Tracking Status header, value suggested to be sent in response to a DNT(do-not-track), possible values: â€œ!â€ â€” under construction â€œ?â€ â€” dynamic â€œGâ€ â€” gateway to multiple parties â€œNâ€ â€” not tracking â€œTâ€ â€” tracking â€œCâ€ â€” tracking with consent â€œPâ€ â€” tracking only if consented â€œDâ€ â€” disregarding DNT â€œUâ€ â€” updated","long-description":null,"type":"RESPONSE"},{"name":"Upgrade","example":"Upgrade: h2c, HTTPS/1.3, IRC/6.9, RTA/x11, websocket","short-description":"Ask the client to upgrade to another protocol. Deprecated in HTTP/2","long-description":"<p> The Upgrade general-header allows the client to specify what additional communication protocols it supports and would like to use if the server finds it appropriate to switch protocols. The server MUST use the Upgrade header field within a 101 (Switching Protocols) response to indicate which protocol(s) are being switched. </p>\n<pre>       Upgrade        = \"Upgrade\" \":\" 1#product\r\n</pre>\n<p> For example, </p>\n<pre>       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\r\n</pre>\n<p> The Upgrade header field is intended to provide a simple mechanism for transition from HTTP/1.1 to some other, incompatible protocol. It does so by allowing the client to advertise its desire to use another protocol, such as a later version of HTTP with a higher major version number, even though the current request has been made using HTTP/1.1. This eases the difficult transition between incompatible protocols by allowing the client to initiate a request in the more commonly supported protocol while indicating to the server that it would like to use a \"better\" protocol if available (where \"better\" is determined by the server, possibly according to the nature of the method and/or resource being requested). </p>\n<p> The Upgrade header field only applies to switching application-layer protocols upon the existing transport-layer connection. Upgrade cannot be used to insist on a protocol change; its acceptance and use by the server is optional. The capabilities and nature of the application-layer communication after the protocol change is entirely dependent upon the new protocol chosen, although the first action after changing the protocol MUST be a response to the initial HTTP request containing the Upgrade header field. </p>\n<p> The Upgrade header field only applies to the immediate connection. Therefore, the upgrade keyword MUST be supplied within a Connection header field (section <a rel=\"xref\" href=\"rfc2616-sec14.html#sec14.10\">14.10</a>) whenever Upgrade is present in an HTTP/1.1 message. </p>\n<p> The Upgrade header field cannot be used to indicate a switch to a protocol on a different connection. For that purpose, it is more appropriate to use a 301, 302, 303, or 305 redirection response. </p>\n<p> This specification only defines the protocol name \"HTTP\" for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of section <a rel=\"xref\" href=\"rfc2616-sec3.html#sec3.1\">3.1</a> and future updates to this specification. Any token can be used as a protocol name; however, it will only be useful if both the client and server associate the name with the same protocol. </p>","type":"RESPONSE"},{"name":"Vary","example":"Vary: Accept-Language Vary: *","short-description":"Tells downstream proxies how to match future request headers to decide whether the cached response can be used rather than requesting a fresh one from the origin server","long-description":"<p> The Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation. For uncacheable or stale responses, the Vary field value advises the user agent about the criteria that were used to select the representation. A Vary field value of \"*\" implies that a cache cannot determine from the request headers of a subsequent request whether this response is the appropriate representation. See section <a rel=\"xref\" href=\"rfc2616-sec13.html#sec13.6\">13.6</a> for use of the Vary header field by caches. </p>\n<pre>       Vary  = \"Vary\" \":\" ( \"*\" | 1#field-name )\r\n</pre>\n<p> An HTTP/1.1 server SHOULD include a Vary header field with any cacheable response that is subject to server-driven negotiation. Doing so allows a cache to properly interpret future requests on that resource and informs the user agent about the presence of negotiation </p>\n<p> on that resource. A server MAY include a Vary header field with a non-cacheable response that is subject to server-driven negotiation, since this might provide the user agent with useful information about the dimensions over which the response varies at the time of the response. </p>\n<p> A Vary field value consisting of a list of field-names signals that the representation selected for the response is based on a selection algorithm which considers ONLY the listed request-header field values in selecting the most appropriate representation. A cache MAY assume that the same selection will be made for future requests with the same values for the listed field names, for the duration of time for which the response is fresh. </p>\n<p> The field-names given are not limited to the set of standard request-header fields defined by this specification. Field names are case-insensitive. </p>\n<p> A Vary field value of \"*\" signals that unspecified parameters not limited to the request-headers (e.g., the network address of the client), play a role in the selection of the response representation. The \"*\" value MUST NOT be generated by a proxy server; it may only be generated by an origin server. </p>","type":"RESPONSE"},{"name":"Via","example":"Via: 1.0 fred, 1.1 example.com (Apache/1.1)","short-description":"Informs the client of proxies through which the response was sent","long-description":"<p> The Via general-header field MUST be used by gateways and proxies to indicate the intermediate protocols and recipients between the user agent and the server on requests, and between the origin server and the client on responses. It is analogous to the \"Received\" field of RFC 822 <a rel=\"bibref\" href=\"rfc2616-sec17.html#bib9\">[9]</a> and is intended to be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of all senders along the request/response chain. </p>\n<pre>      Via =  \"Via\" \":\" 1#( received-protocol received-by [ comment ] )\r\n      received-protocol = [ protocol-name \"/\" ] protocol-version\r\n      protocol-name     = token\r\n      protocol-version  = token\r\n      received-by       = ( host [ \":\" port ] ) | pseudonym\r\n      pseudonym         = token\r\n</pre>\n<p> The received-protocol indicates the protocol version of the message received by the server or client along each segment of the request/response chain. The received-protocol version is appended to the Via field value when the message is forwarded so that information about the protocol capabilities of upstream applications remains visible to all recipients. </p>\n<p> The protocol-name is optional if and only if it would be \"HTTP\". The received-by field is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, it MAY be replaced by a pseudonym. If the port is not given, it MAY be assumed to be the default port of the received-protocol. </p>\n<p> Multiple Via field values represents each proxy or gateway that has forwarded the message. Each recipient MUST append its information such that the end result is ordered according to the sequence of forwarding applications. </p>\n<p> Comments MAY be used in the Via header field to identify the software of the recipient proxy or gateway, analogous to the User-Agent and Server header fields. However, all comments in the Via field are optional and MAY be removed by any recipient prior to forwarding the message. </p>\n<p> For example, a request message could be sent from an HTTP/1.0 user agent to an internal proxy code-named \"fred\", which uses HTTP/1.1 to forward the request to a public proxy at nowhere.com, which completes the request by forwarding it to the origin server at www.ics.uci.edu. The request received by www.ics.uci.edu would then have the following Via header field: </p>\n<pre>       Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\r\n</pre>\n<p> Proxies and gateways used as a portal through a network firewall SHOULD NOT, by default, forward the names and ports of hosts within the firewall region. This information SHOULD only be propagated if explicitly enabled. If not enabled, the received-by host of any host behind the firewall SHOULD be replaced by an appropriate pseudonym for that host. </p>\n<p> For organizations that have strong privacy requirements for hiding internal structures, a proxy MAY combine an ordered subsequence of Via header field entries with identical received-protocol values into a single such entry. For example, </p>\n<pre>       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy\r\n</pre>\n<pre>        could be collapsed to\r\n</pre>\n<pre>       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy\r\n</pre>\n<p> Applications SHOULD NOT combine multiple entries unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms. Applications MUST NOT combine entries which have different received-protocol values. </p>","type":"RESPONSE"},{"name":"Warning","example":"Warning: 199 Miscellaneous warning","short-description":"A general warning about possible problems with the entity body","long-description":"<p> The Warning general-header field is used to carry additional information about the status or transformation of a message which might not be reflected in the message. This information is typically used to warn about a possible lack of semantic transparency from caching operations or transformations applied to the entity body of the message. </p>\n<p> Warning headers are sent with responses using: </p>\n<pre>       Warning    = \"Warning\" \":\" 1#warning-value\r\n</pre>\n<pre>       warning-value = warn-code SP warn-agent SP warn-text\r\n                                             [SP warn-date]\r\n</pre>\n<pre>       warn-code  = 3DIGIT\r\n       warn-agent = ( host [ \":\" port ] ) | pseudonym\r\n                       ; the name or pseudonym of the server adding\r\n                       ; the Warning header, for use in debugging\r\n       warn-text  = quoted-string\r\n       warn-date  = &lt;\"&gt; HTTP-date &lt;\"&gt;\r\n</pre>\n<p> A response MAY carry more than one Warning header. </p>\n<p> The warn-text SHOULD be in a natural language and character set that is most likely to be intelligible to the human user receiving the response. This decision MAY be based on any available knowledge, such as the location of the cache or user, the Accept-Language field in a request, the Content-Language field in a response, etc. The default language is English and the default character set is ISO-8859-1. </p>\n<p> If a character set other than ISO-8859-1 is used, it MUST be encoded in the warn-text using the method described in RFC 2047 [14]. </p>\n<p> Warning headers can in general be applied to any message, however some specific warn-codes are specific to caches and can only be applied to response messages. New Warning headers SHOULD be added after any existing Warning headers. A cache MUST NOT delete any Warning header that it received with a message. However, if a cache successfully validates a cache entry, it SHOULD remove any Warning headers previously attached to that entry except as specified for </p>\n<p> specific Warning codes. It MUST then add any Warning headers received in the validating response. In other words, Warning headers are those that would be attached to the most recent relevant response. </p>\n<p> When multiple Warning headers are attached to a response, the user agent ought to inform the user of as many of them as possible, in the order that they appear in the response. If it is not possible to inform the user of all of the warnings, the user agent SHOULD follow these heuristics: </p>\n<pre>      - Warnings that appear early in the response take priority over\r\n        those appearing later in the response.\r\n</pre>\n<pre>      - Warnings in the user's preferred character set take priority\r\n        over warnings in other character sets but with identical warn-\r\n        codes and warn-agents.\r\n</pre>\n<p> Systems that generate multiple Warning headers SHOULD order them with this user agent behavior in mind. </p>\n<p> Requirements for the behavior of caches with respect to Warnings are stated in section 13.1.2. </p>\n<p> This is a list of the currently-defined warn-codes, each with a recommended warn-text in English, and a description of its meaning. </p>\n<p> 110 Response is stale MUST be included whenever the returned response is stale. </p>\n<p> 111 Revalidation failed MUST be included if a cache returns a stale response because an attempt to revalidate the response failed, due to an inability to reach the server. </p>\n<p> 112 Disconnected operation SHOULD be included if the cache is intentionally disconnected from the rest of the network for a period of time. </p>\n<p> 113 Heuristic expiration MUST be included if the cache heuristically chose a freshness lifetime greater than 24 hours and the response's age is greater than 24 hours. </p>\n<p> 199 Miscellaneous warning The warning text MAY include arbitrary information to be presented to a human user, or logged. A system receiving this warning MUST NOT take any automated action, besides presenting the warning to the user. </p>\n<p> 214 Transformation applied MUST be added by an intermediate cache or proxy if it applies any transformation changing the content-coding (as specified in the Content-Encoding header) or media-type (as specified in the Content-Type header) of the response, or the entity-body of the response, unless this Warning code already appears in the response. </p>\n<p> 299 Miscellaneous persistent warning The warning text MAY include arbitrary information to be presented to a human user, or logged. A system receiving this warning MUST NOT take any automated action. </p>\n<p> If an implementation sends a message with one or more Warning headers whose version is HTTP/1.0 or lower, then the sender MUST include in each warning-value a warn-date that matches the date in the response. </p>\n<p> If an implementation receives a message with a warning-value that includes a warn-date, and that warn-date is different from the Date value in the response, then that warning-value MUST be deleted from the message before storing, forwarding, or using it. (This prevents bad consequences of naive caching of Warning header fields.) If all of the warning-values are deleted for this reason, the Warning header MUST be deleted as well. </p>","type":"RESPONSE"},{"name":"WWW-Authenticate","example":"WWW-Authenticate: Basic","short-description":"Indicates the authentication scheme that should be used to access the requested entity","long-description":"<p> The WWW-Authenticate response-header field MUST be included in 401 (Unauthorized) response messages. The field value consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the Request-URI. </p>\n<pre>       WWW-Authenticate  = \"WWW-Authenticate\" \":\" 1#challenge\r\n</pre>\n<p> The HTTP access authentication process is described in \"HTTP Authentication: Basic and Digest Access Authentication\" [43]. User agents are advised to take special care in parsing the WWW- Authenticate field value as it might contain more than one challenge, or if more than one WWW-Authenticate header field is provided, the contents of a challenge itself can contain a comma-separated list of authentication parameters. </p>","type":"RESPONSE"},{"name":"Content-Security-Policy","example":"Helps to protect against XSS attacks. See MDN for more details","short-description":"Refresh","long-description":null,"type":"RESPONSE"},{"name":"Refresh","example":"Refresh: 10;http://www.example.org/","short-description":"Redirect to a URL after an arbitrary delay expressed in seconds","long-description":null,"type":"RESPONSE"},{"name":"X-Powered-By","example":"X-Powered-By: Brain/0.6b","short-description":"Can be used by servers to send their name and version","long-description":null,"type":"RESPONSE"},{"name":"X-Request-ID","example":"Allows the server to pass a request ID that clients can send back to let the server correlate the request","short-description":"X-UA-Compatible","long-description":null,"type":"RESPONSE"},{"name":"X-UA-Compatible","example":"Sets which version of Internet Explorer compatibility layer should be used. Only used if you need to support IE8 or IE9. See StackOverflow","short-description":"X-XSS-Protection","long-description":null,"type":"RESPONSE"},{"name":"X-XSS-Protection","example":"Now replaced by the Content-Security-Policy header, used in older browsers to stop pages load when an XSS attack is detected","short-description":"","long-description":null,"type":"RESPONSE"}]